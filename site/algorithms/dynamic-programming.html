
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Programming Algorithms and Problem Solutions Guide | Elijah's Notes</title>

    <!-- SEO Meta Tags -->
    <meta name="description" content="A comprehensive guide covering various dynamic programming algorithms and their implementations, including knapsack, sequence alignment, and tree-based problems. Includes detailed explanations of problem-solving approaches, correctness proofs, and runtime analysis for each algorithm, with practical Python implementations.">
    <meta name="author" content="Elijah Melton">
    <meta name="robots" content="index, follow">
    <meta name="generator" content="Custom Static Site Generator">
    <link rel="canonical" href="https://notes.elimelt.com/algorithms/dynamic-programming.html">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:title" content="Dynamic Programming Algorithms and Problem Solutions Guide">
    <meta property="og:description" content="A comprehensive guide covering various dynamic programming algorithms and their implementations, including knapsack, sequence alignment, and tree-based problems. Includes detailed explanations of problem-solving approaches, correctness proofs, and runtime analysis for each algorithm, with practical Python implementations.">
    <meta property="og:url" content="https://notes.elimelt.com/algorithms/dynamic-programming.html">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Dynamic Programming Algorithms and Problem Solutions Guide">
    <meta name="twitter:description" content="A comprehensive guide covering various dynamic programming algorithms and their implementations, including knapsack, sequence alignment, and tree-based problems. Includes detailed explanations of problem-solving approaches, correctness proofs, and runtime analysis for each algorithm, with practical Python implementations.">

    <meta name="keywords" content="dynamic programming,optimization,algorithm analysis">

    <!-- Schema.org JSON-LD -->
    <script type="application/ld+json">
    {"@context": "https://schema.org", "@type": "Article", "headline": "Dynamic Programming Algorithms and Problem Solutions Guide", "dateModified": "2025-02-11T18:54:45.969330", "description": "A comprehensive guide covering various dynamic programming algorithms and their implementations, including knapsack, sequence alignment, and tree-based problems. Includes detailed explanations of problem-solving approaches, correctness proofs, and runtime analysis for each algorithm, with practical Python implementations.", "articleSection": "Algorithms", "keywords": "dynamic programming,optimization,algorithm analysis"}
    </script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/contrib/auto-render.min.js"></script>

    <!-- Configure KaTeX auto-render -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$", right: "$", display: true},
                    {left: "\\[", right: "\\]", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

<style>
    :root {
        --text-color: #1a1a1a;
        --background-color: #ffffff;
        --accent-color: #2563eb;
        --border-color: #e5e7eb;
        --nav-background: rgba(255, 255, 255, 0.95);
    }

    @media (prefers-color-scheme: dark) {
        :root {
            --text-color: #f3f4f6;
            --background-color: #1a1a1a;
            --accent-color: #60a5fa;
            --border-color: #374151;
            --nav-background: rgba(26, 26, 26, 0.95);
        }
    }

    body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        line-height: 1.6;
        max-width: 50rem;
        margin: 0 auto;
        padding: 2rem;
        color: var(--text-color);
        background: var(--background-color);
    }

    nav {
        position: sticky;
        top: 0;
        background: var(--nav-background);
        backdrop-filter: blur(10px);
        border-bottom: 1px solid var(--border-color);
        padding: 1rem 0;
        margin-bottom: 2rem;
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        z-index: 1000;
    }

    nav a {
        color: var(--accent-color);
        text-decoration: none;
        padding: 0.5rem 1rem;
        border-radius: 4px;
        transition: background-color 0.2s;
    }

    nav a:hover {
        background-color: var(--border-color);
    }

    .breadcrumbs {
        margin-bottom: 2rem;
        color: var(--text-color);
        opacity: 0.8;
    }

    .breadcrumbs a {
        color: var(--accent-color);
        text-decoration: none;
    }

    .content {
        margin-top: 2rem;
    }

    h1, h2, h3, h4, h5, h6 {
        margin-top: 2rem;
        margin-bottom: 1rem;
        line-height: 1.3;
    }

    code {
        background: var(--border-color);
        padding: 0.2rem 0.4rem;
        border-radius: 3px;
        font-size: 0.9em;
        font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
    }

    pre {
        background: var(--border-color);
        padding: 1rem;
        border-radius: 4px;
        overflow-x: auto;
        margin: 1.5rem 0;
    }

    pre code {
        background: none;
        padding: 0;
        border-radius: 0;
    }

    img {
        max-width: 100%;
        height: auto;
        border-radius: 4px;
        margin: 1.5rem 0;
    }

    .meta {
        color: var(--text-color);
        opacity: 0.8;
        font-size: 0.9em;
        margin-bottom: 2rem;
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
    }

    .tags {
        margin-top: 2rem;
        padding-top: 1rem;
        border-top: 1px solid var(--border-color);
    }

    .tags a {
        display: inline-block;
        background: var(--border-color);
        color: var(--text-color);
        padding: 0.2rem 0.6rem;
        border-radius: 3px;
        text-decoration: none;
        font-size: 0.9em;
        margin-right: 0.5rem;
        margin-bottom: 0.5rem;
    }

    .tags a:hover {
        background: var(--accent-color);
        color: white;
    }

    a {
        color: #3391ff;
    }

    table {
        width: 100%;
        border-collapse: collapse;
        margin: 1.5rem 0;
    }

    th, td {
        padding: 0.75rem;
        border: 1px solid var(--border-color);
    }

    th {
        background: var(--border-color);
    }

    .md-content table td, .md-content table th {
        background: black;
    }

    blockquote {
        margin: 1.5rem 0;
        padding-left: 1rem;
        border-left: 4px solid var(--accent-color);
        color: var(--text-color);
        opacity: 0.8;
    }

    .katex-display {
        overflow: auto hidden;
        padding: 1em 0;
        margin: 0.5em 0;
    }

    .katex-display > .katex {
        white-space: normal;
    }

    .katex {
        font-size: 1.1em;
        display: inline;
        line-height: 1.2;
    }

    .katex-html {
        display: inline-block;
        vertical-align: middle;
    }

    .katex .strut {
        display: none;
    }

    .katex-display .katex {
        display: block;
        text-align: center;
    }

    .katex-display > .katex > .katex-html {
        display: block;
        max-width: 100%;
        overflow-x: auto;
        padding: 0.5em 0;
        min-height: 40px;
    }
</style></head>
<body>
    <header>
        <nav role="navigation" aria-label="Main navigation">
            <a href="/index.html">Home</a>
<a href="/categories/index.html">Categories</a>
<a href="/tags/index.html">Tags</a>
        </nav>
        <div class="breadcrumbs" role="navigation" aria-label="Breadcrumb">
            <a href="/index.html">Home</a> » <a href="/categories/algorithms.html">Algorithms</a> » Dynamic Programming Algorithms and Problem Solutions Guide
        </div>
    </header>
    <main role="main">
        <article>
            <h1>Dynamic Programming Algorithms and Problem Solutions Guide</h1>
            <div class="meta">
                <time datetime="2025-02-11T18:54:45.969330">
                    Last modified: 2025-02-11
                </time>
                <span>Category: <a href="/categories/algorithms.html">Algorithms</a></span>
            </div>
            <div class="content">
                <h1 id="dynamic-programming">Dynamic Programming</h1>
<p><strong>Dynamic Programming</strong> is an algorithmic paradigm where you break up a problem into a series of <strong>overlapping</strong> sub-problems, building up solutions to progressively larger subproblems until the original answer is obtained. The key efficiency of DP is to <strong>memoize</strong> the answers to sub problems, often yielding a polynomial time algorithm.</p>
<p>You can design dynamic programming algorithms by induction, with the added construct of somehow memorizing/caching previously solved problems. The key then becomes finding a valid recurrence relation that relates a given instance of the problem to its composite subproblems.</p>
<h2 id="weighted-interval-scheduling">Weighted Interval Scheduling</h2>
<p><strong>Problem</strong>: Given a set of jobs $J$ with start times $s_i$, finish times $f_i$, and weights $w_i$, find the maximum weight subset of jobs that are compatible with each other.</p>
<p>A naive approach would be to use the following induction:</p>
<p>Given jobs $j_1, j_2, \ldots, j_n$, suppose we can compute the optimum job scheduling for $< n$ jobs.</p>
<p>Then, for any $n$ jobs we can compute $OPT$ as:</p>
<ul>
<li>Case 1: $j_n \notin OPT(j_1, j_2, \ldots, j_n)$:</li>
<li>Then just return $OPT(j_1, j_2, \ldots, j_{n - 1})$</li>
<li>Case 2: $j_n \in OPT(j_1, j_2, \ldots, j_n)$:</li>
<li>Delete jobs not compatible with $j_n$ and recurse on that new subset of jobs</li>
</ul>
<p>However, this approach is unfortunately still exponential, since there are potentially $2^n$ possible subsets of jobs to consider. Note that this problem is equivalent to maximum independent set, which is NP-complete. To differentiate our solution from the general (supposed) unsolvability of this problem, we can instead rely on an extra property of our inputs, namely that they are partially order-able.</p>
<p>So we sort by finishing time of each job, which reduces the number of subproblems from $O(2^n) \to O(n)$, i.e. the $n$ possible prefix subsets of our sorted jobs.</p>
<p><strong>Algorithm</strong>: Given weighted jobs sorted by finish time, suppose we can compute the $OPT$ for $< n$ jobs.</p>
<ul>
<li>Case 1: $j_n \in OPT$:</li>
<li>So all jobs $i$ that are not compatible with $n$ are not in $OPT$</li>
<li>We can find this efficiently, i.e. $p(n) = $ largest index $i < n$ such that $j_i$ is compatible with $j_n$ (binary search based on $s_j, f_i$)</li>
<li>Then, we just need to find $OPT(j_1, \ldots, j_{p(n)})$</li>
<li>Case 2: $j_n \notin OPT$:</li>
<li>Then we can return $OPT(j_1, \ldots, j_{n - 1})$</li>
<li>Our actual $OPT(j_1, \ldots, j_n)$ is then just the maximum of these two cases</li>
</ul>
<pre><code class="language-python"># J[i] = (s_i, f_i, c_i)
def max_weighted_interval_subset(J: tuple[int, int, int]) -&gt; int:
    J = sorted(J, key=lambda x: x[1])
    n = len(J)
    memo = [0] * n

    def p(n: int) -&gt; int:
        for i in range(n - 1, -1, -1):
            if J[i][1] &lt;= J[n][0]:
                return i
        return -1

    def dp(n: int) -&gt; int:
        if n &lt; 0:
            return 0
        if memo[n] != 0:
            return memo[n]
        memo[n] = max(J[n][2] + dp(p(n)), dp(n - 1))
        return memo[n]

    return dp(n - 1)
</code></pre>
<h2 id="knapsack-problem">Knapsack Problem</h2>
<p><strong>Problem</strong>: Given $n$ items with weights $w_1, \ldots, w_n$ and values $v_1, \ldots, v_n$, and a knapsack of capacity $W$, find the maximum value subset of items that fit in the knapsack.</p>
<p>In other words, let $I$ be our set of items, and $S \subseteq I$ be the items we select. We want to find the maximum value of $S$ such that $\sum_{i \in S} w_i \le W$</p>
<h3 id="what-are-we-inducting-on">What are we inducting on?</h3>
<p>Assume $P(i, w)$ holds $\forall w \in [0, W]$, and then show $P(i + 1, w)$ holds $\forall w \in [0, W]$. This is a <strong>bottom-up</strong> approach, where we start from the base case and build up to the final solution.</p>
<p><strong>Algorithm</strong>: Define $OPT(i, w)$ to be the solution for items $1, \ldots, i$ with a knapsack of capacity $w$. Then, we have the following induction:</p>
<p>$$
OPT(i, w) = \begin{cases}
OPT(i - 1, w) & \text{if } w_i > w \\
\max(v_i + OPT(i - 1, w - w_i), OPT(i - 1, w)) & \text{otherwise}
\end{cases}
$$</p>
<pre><code class="language-python"># recursive
def knapsack_rec(W: int, w: list[int], v: list[int]) -&gt; int:
    n = len(w)
    M = [[-1] * (W + 1) for _ in range(n + 1)]

    def dp(i: int, w: int) -&gt; int:
      if M[i][w] != -1:
        return M[i][w]

      if i &lt; 0 or w == 0:
        M[i][w] = 0
      elif w[i] &gt; w:
        M[i][w] = dp(i - 1, w)
      else:
        M[i][w] = max(v[i] + dp(i - 1, w - w[i]), dp(i - 1, w))
      return M[i][w]

    return dp(n, W)

# iterative
def knapsack_it(W: int, w: list[int], v: list[int]) -&gt; int:
    n = len(w)
    M = [[0] * (W + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        for j in range(1, W + 1):
            if w[i - 1] &gt; j:
                M[i][j] = M[i - 1][j]
            else:
                M[i][j] = max(v[i - 1] + M[i - 1][j - w[i - 1]], M[i - 1][j])

    return M[n][W]
</code></pre>
<h2 id="string-building">String Building</h2>
<p>Given 3 integers $n \geq 1$ and $k_A,k_B \geq 1$, design an algorithm that runs in time polynomial in $n, k_A, k_B$ and outputs the number of length $n$ strings composed of copies of $A, B$ such that no more than $k_A$ copies of $A$ are placed consecutively and no more than $k_B$ copies of $B$ are placed consecutively.</p>
<p><strong>Algorithm</strong>:</p>
<pre><code class="language-python">A, B = 0, 1

def num_strings(n, ka, kb):
  dp = [[None, None]] * (n + 1)
  dp[1][A], dp[1][B] = None, None, 1, 1

  if ka == 0 or kb == 0:
    if ka &lt; n and kb &lt; n:
      return 0
    else:
      return 1

  def f(i, c):
    if i == 1:
      return 1

    if dp[i][c] != None:
      return dp[i][c]

    kc = ka if c == A else kb
    notc = A if c == B else B

    if i &lt;= kc:
      dp[i][c] = f(i - 1, notc) + f(i - 1, c)
    else:
      dp[i][c] = sum(f(i - j, notc) for j in range(1, kc + 1))

    return dp[i][c]

  return f(n, A) + f(n, B)
</code></pre>
<p><strong>Correctness</strong>: A string is valid if it has $\le k_A$ consecutive $A$ and $\le k_B$ consecutive $B$.</p>
<p>Define $OPT(i, c)$ for $i, k_A, k_B \ge 1$ to be the number of valid strings ending in character $c \in \{A, B\}$. Our base case is $OPT(1, c) = 1$, since there is only one length-1 string ending in $c$.</p>
<p>Assuming we can compute $OPT(i, c)$ for $i < n$, we can compute $OPT(n, c)$ as follows:</p>
<p>$$
OPT(n, c) = \begin{cases}
1 & n = 1 \\
OPT(n - 1, c') + OPT(n - 1, c) & 2 \le n \le k_c \\
\sum_{j = 1}^{k_c} OPT(n - j, c') & n > k_c
\end{cases}
$$</p>
<p>where $c'$ is the other character, and $k_c$ is the maximum number of consecutive $c$ allowed.</p>
<p>For the case where $n > k_c$, we can sum over all possible lengths of the last run of $c$, and then recurse on the remaining string. For a run of $c$ of length $k$ in a string of length $n$, we must have the first $n - k$ characters be some other valid string ending in $c'$, since otherwise our string would end in a run of $c$ of length $> k$. Therefore, we only need to count the number of strings of left $n - k_c \le i \le n - 1$ ending in $c'$, since this is exactly the number of valid strings ending in runs of $1 \le k \le k_c$ $c$.</p>
<p>In the case where $2 \le n \le k_c$, we know that there is no way we'd have a run of $c$ of more than $k_c$, so we can simply count the number of valid strings of size $n - 1$ that either end in a $c$ or a $c'$. Then, we can add a $c$ to the end of all those strings to get our valid strings of length $n$.</p>
<p>Therefore, we cover all cases and $OPT(n, c)$ computes the correct value $\forall n \ge 1$.</p>
<p>To compute the total number of valid strings of length $n$, we simply return $OPT(n, A) + OPT(n, B)$, since all valid strings either end in $A$ or $B$.</p>
<h3 id="running-time">Running Time</h3>
<p>We compute $2n$ total values of $OPT(n, c)$, $n$ corresponding to strings ending in $A$, and $n$ ending in $B$. When $n \le k_c$, we can compute our answer in constant time using the values previously computed. When $n > k_c$, we need to sum over $k_c$ previously computed values, which is $O(k_c)$. Therefore, our total running time is at most $O(nk_Ak_B)$.</p>
<h2 id="post-office">Post Office</h2>
<p><strong>Problem</strong>: Interstate highway 5 is a straight highway from Washington all the way to California. There are $n$ villages alongside this highway. Think about the highway as an integer axis, and the position of village $i$ is an integer $x_i$ along this axis. Assume that there are no two villages in the same position, i.e., $x_i \neq x_j$ for $i \neq j$. The distance between two villages $x_i,x_j$ is simply $| x_i - x_j |$.</p>
<p>USPS is interested in building k post offices in some, but not necessarily all of the villages along highway 5, for some $1 \leq k \leq n$. A village and the post office in it have the same position. We want to choose the positions of these post offices so that the sum of the distances from each village to its nearest post office is minimized. Design an algorithm that runs in time polynomial in $n$ and outputs the minimum possible sum of distances to the optimal location for post offices.</p>
<p><strong>Algorithm</strong>:</p>
<pre><code class="language-python">def min_dist_td(X, K):
  N = len(X)
  if K &gt;= N:
    return 0

  dp = [[None] * (K + 1) for _ in range(N + 1)]
  for n in range(N + 1):
    for k in range(n, K + 1):
      dp[n][k] = 0

  def f(n, k):
    if n &gt;= k:
      return 0

    if dp[n][k] is not None:
      return dp[n][k]

    dp[n][k] = float('inf')

    if k == 1:
      dp[n][k] = sum(abs(X[i - 1] - X[n - 1]) for i in range(1, n))
    else:
      for i in range(k - 1, n):
        dp[n][k] = min(
            dp[n][k],
            f(i, k - 1) + sum(
              min(
                abs(X[j - 1] - X[n - 1]),
                abs(X[j - 1] - X[i - 1])
              ) for j in range(i + 1, n))
        )

    return dp[n][k]

  def c(i):
    return f(i, k) + sum(abs(X[i - 1] - X[j - 1]) for j in range(i + 1, n + 1))

  return min(c(i) for i in range(k, n + 1))
</code></pre>
<h3 id="correctness">Correctness</h3>
<p>Define $f(n, k)$ to be the minimum sum of distances from the nearest post office of the first $n$ villages to $k$ post offices given the $kth$ post office is placed in village $n$.</p>
<p>When $n \le k$, we have a sum of $0$, since every village has a post office. Then, assuming $f(i, k)$ is correct $\forall k > 0, 0 \le i < n$, we can calculate $f(n, k)$ by considering every possible placement of the $k - 1th$ post office, and choose the one that minimizes the sum of distances for villages between the $k - 1th$ and $kth$ post office. However, if $k = 1$, then the only post office we can place is the one in $x_n$, so we only need to find the distances of towns $x_1, \ldots, x_{n - 1}$ from $x_n$.</p>
<p>In the case where $k > 1$, we must consider placing a post office in towns $x_{k - 1}, x_k, \ldots, x_{n - 1}$, since it doesn't make sense to place the $k - 1th$ post office before we've seen $k - 1$ villages, and we can only place up to the village before $x_n$, since by construction it is the last of our $k$ post offices places in the $n$ towns. Therefore, we have the following recurrence:</p>
<p>$$
f(n, k) = \begin{cases}
0 & n \le k \\
\sum_{i = 1}^{n - 1} | x_i - x_n | & k = 1 \\
\min_{k - 1 \le i < n} \left( f(i, k - 1) + \sum_{i < j < n} \min \left( | x_j - x_n |, | x_j - x_i | \right) \right) & \text{otherwise}\\
\end{cases}
$$</p>
<p>Since $f(i, k - 1)$ holds for $i < n$, and we always choose the placement of the $k - 1th$ post office that minimizes the total sum of distances, $f(n, k)$ is correctly computed.</p>
<p>Now define $c(i)$ for $k \le i \le n$ to be the total sum of distances if we place the $kth$ post office in village $x_i$ (i.e. the last post office), and all other post offices optimally. Since $f(i, k)$ correctly computes the sum of distances in this case up to the $ith$ post office, and we are guaranteed that no other post office comes after the one placed in $x_i$, all villages $x_j$ for $j > i$ will be closest to the post office in $x_i$.</p>
<p>Therefore, we can compute $c(i)$ as follows:</p>
<p>$$
c(i) = f(i, k) + \sum_{i < j \le n} | x_i - x_j |
$$</p>
<p>Finally, in order to compute our final answer, we just need to check every placement of the last post office and return the minimum sum of distances returned. Thus, we have a minimal sum of distances of...</p>
<p>$$
\min_{k \le i \le n} c(i)
$$</p>
<p>And so our overall optimum is as follows:</p>
<p>$$
OPT(n, k) = \min_{k \le i \le n} \{f(i, k) + \sum_{i + 1 \le j \le n} | x_i - x_j |\}
$$</p>
<p><strong>Running Time</strong>: Computing $f(n, k)$ runs in $O(n^2)$ time, and since we need to run this calculation over at most $nk$ values, to fully memoize all inputs it takes $O(kn^3)$.</p>
<p>Then, each $c(i)$ takes constant time to retrieve each $f(i, k)$, and an additional $O(n)$ to compute the sum of the remaining distances, for a total of $O(n)$.</p>
<p>Finally, we call $c(i)$ $O(n)$ times, for a total of $O(n^2)$.</p>
<p>Thus, our running time is $O(kn^3)$</p>
<h2 id="rna-secondary-structure">RNA Secondary Structure</h2>
<p><strong>Problem</strong>: Given an RNA molecule $B = b_1 b_2 \ldots b_n$, find a secondary structure $S$ that maximizes the number of base pairs.</p>
<p>Note that maximizing the number of base pairs is a practical problem, since RNA molecules fold into a secondary structure that minimizes free energy, and the number of base pairs is a good proxy for free energy.</p>
<p><em>Rules</em>:</p>
<ul>
<li><em>Watson-Crick base pairs</em>: $A-U, U-A, C-G, G-C$</li>
<li><em>No sharp turns</em>: the end pair are separated by at least 4 intervening base pairs, i.e. $(b_i, b_j) \in S \to |i - j| > 4$</li>
<li><em>No crossing</em>: If $(b_i, b_j), (b_k, b_l) \in S \to \neg (i < k < j < l)$</li>
</ul>
<p><strong>Algorithm</strong>:</p>
<pre><code class="language-python"># Top Down Recursive

WC = { 'A': 'U', 'U': 'A', 'C': 'G', 'G': 'C' }

def ssr(B):
  N = len(B)
  dp = [[None] * N for _ in range(N)]

  for i in range(N) for j in range(N):
    if abs(j - i) &lt;= 4:
      dp[i][j] = 0

  def f(i, j):
    if dp[i][j] is not None:
      return dp[i][j]

    for t in range(i, j - 5 + 1):
      if WC[B[t]] == B[j]:
        dp[i][j] = max(dp[i][j], 1 + f(i, t - 1) + f(t + 1, j - 1))

    return dp[i][j]

  return f(0, N - 1)

def ssi(B):
  N = len(B)
  dp = [[0] * N for _ in range(N)]

  for l in range(2, N + 1):
    for i in range(N - l + 1):
      j = i + l - 1
      if j - i &lt;= 4:
        dp[i][j] = 0
      else:
        dp[i][j] = dp[i][j - 1]
        for t in range(i, j - 5 + 1):
          if WC[B[t]] == B[j]:
            dp[i][j] = max(dp[i][j], 1 + dp[i][t - 1] + dp[t + 1][j - 1])
</code></pre>
<p><strong>Correctness</strong>:</p>
<p>Let $OPT(i, j)$ be the maximum number of base pairs in a secondary structure of the substring $b_i, b_{i + 1}, \ldots, b_j$.</p>
<p><strong>Base Case</strong>: $\forall i, j$, we have $|j - i| \le 4 \to OPT(i, j) = 0$</p>
<p>Suppose that for some $l = j - i \ge 4$, we have computed all $OPT(i, j)$. Then to compute $OPT(i, j)$ for $|j - i| > l$, we do the following:</p>
<ul>
<li>Case 1: Base $J$0 is not involved in a pair in our solution</li>
<li>$J$1, since we have $J$2 solved for $J$3</li>
<li>Case 2: Base $J$4 pairs with $J$5 for some $J$6</li>
<li>$J$7</li>
</ul>
<h2 id="sequence-alignment">Sequence Alignment</h2>
<p><strong>Problem</strong>: Given two strings $J$8 and $J$9, find an alignment with the minimum number of mismatches and gaps.</p>
<p>An alignment is a set of ordered pairs $s_i$0 such that $s_i$1 and $s_i$2.</p>
<ul>
<li><strong>Correctness</strong>: Let $s_i$3 be the min cost of aligning $s_i$4 and $s_i$5.</li>
</ul>
<p>Our base case is when either $s_i$6 or $s_i$7 are $s_i$8, we just need to do $s_i$9 or $f_i$0 deletes respectively.</p>
<ul>
<li>Case 1: $f_i$1 matches $f_i$2</li>
<li>Then, if $f_i$3, add one, and otherwise add zero to $f_i$4.</li>
<li>Case 2: $f_i$5 leaves $f_i$6 unmatched</li>
<li>Then, pay the gap cost for $f_i$7</li>
<li>Case 3: $f_i$8 leaves $f_i$9 unmatched</li>
<li>Then, pay gap cost for $w_i$0</li>
</ul>
<pre><code class="language-python"># Bottom up, non memory optimized - T = O(mn), S = O(mn)
def seq_alignment(x, y):
  m, n = len(x), len(y)
  dp = [[None] * (n + 1) for _ in range(m + 1)]
  for i in range(m + 1):
    dp[i][0] = i
  for j in range(n + 1):
    dp[0][j] = j

  for i in range(1, m + 1):
    for j in range(1, n + 1):
      dp[i][j] = max(
        (0 if x[i] == y[j] else 1) + dp[i - 1][j - 1],
        1 + dp[i - 1][j],
        1 + d[i][j - 1]
      )

  return dp[m][n]
</code></pre>
<p>Note that in computational biology, you'll be running this on strings with thousands or even millions of characters. Therefore, the space starts to become a problem. For instance, if $w_i$1, we do $w_i$2 operations (which isn't terrible), but we end up with a $w_i$3 GB <code>dp</code> matrix.</p>
<p>You can optimize the space by only tracking the previous row of <code>dp</code>.</p>
<pre><code class="language-python"># Bottom up DP, optimized for space
def seq_alignment(x, y):
  m, n = len(x), len(y)
  # base cases covered
  dp_prev = list(range(m + 1))
  dp_curr = [None] * (m + 1)

  for i in range(1, m + 1):
    dp_curr[0] = i
    for j in range(1, n + 1):
      dp[curr] = min(
        (0 if x[i] == y[j] else 1) + dp_prev[j - 1],
        1 + dp_prev[j],
        1 + dp_curr[j - 1]
      )
    for j in range(1, n + 1):
      dp_old[j] = dp_curr[j]

  return dp_curr[n]
</code></pre>
<h2 id="longest-path-in-a-dag">Longest Path in a DAG</h2>
<p><strong>Problem</strong> Given a DAG $w_i$4, find the longest path.</p>
<p><em>Note</em>: This problem is NP-hard for general directed graphs , as it has the Hamiltonian Path as a special case. However, with a DAG you can solve this in polynomial time.</p>
<p><strong>Approach</strong>: Since $w_i$5 is a DAG, it has a topological sort. Start by sorting vertices in their topological order.</p>
<p>Let $w_i$6 be the length of the longest path that ends at vertex $w_i$7 in the topological sort. We just need to guess the last edge of the longest path that ends in $w_i$8.</p>
<p>$$
OPT(j) = \max_{k \to j} \{ OPT(k) + 1 \}
$$</p>
<p>Then, to get our answer we can output...</p>
<p>$$
\max_{j \in [1, n]} OPT(j)
$$</p>
<h2 id="longest-increasing-subsequence">Longest Increasing Subsequence</h2>
<p>Given a sequence of numbers $w_i$9, find the longest increasing (not necessarily contiguous) subsequence.</p>
<p>Define $j_1, j_2, \ldots, j_n$0 as LIS that ends at $j_1, j_2, \ldots, j_n$1. Our approach is to guess the previous element $j_1, j_2, \ldots, j_n$2. Our base case is $j_1, j_2, \ldots, j_n$3, and for any $j_1, j_2, \ldots, j_n$4 such that $j_1, j_2, \ldots, j_n$5, $j_1, j_2, \ldots, j_n$6, $j_1, j_2, \ldots, j_n$7.</p>
<p>$$
OPT(j) = \begin{cases}
1 & j = 1 \\
1 + \max_{k < j} \{ OPT(k) : x_k < x_j \} & \text{otherwise}
\end{cases}
$$</p>
<pre><code class="language-python">def LIS(X):
  n = len(X)
  dp = [None] * (n + 1)
  dp[0], dp[1] = 0, 1

  def f(i):
    if dp[i] is None:
      dp[i] = 1 + max([0] + [f(k) for k in range(i) if X[k - 1] &lt; X[i - 1]])

    return dp[i]

  return max(f(i) for i in range(1, n + 1))
</code></pre>
<h2 id="shortest-paths-with-negative-edge-weights-bellman-ford">Shortest Paths with Negative Edge Weights (Bellman-Ford)</h2>
<p>Given a weighted directed graph $j_1, j_2, \ldots, j_n$8, and a source vertex $j_1, j_2, \ldots, j_n$9e = (u, v) \in E$< n$0c_e = c_{u, v}$< n$1s$ to all other vertices.</p>
<p><em>Note</em>: if $< n$2 has a negative cycle, there is no solution, so suppose $< n$3 has no negative cycles.</p>
<p><strong>Approach</strong>: Define $< n$4 as the length of the shortest path from $< n$5 among all paths that use at most $< n$6 edges. We induct on $< n$7.</p>
<ul>
<li><em>Case 1</em>: Shortest path from $< n$8 has $< n$9 edges:</li>
<li>$n$0</li>
<li><em>Case 2</em>: Shortest path from $n$1 has exactly $n$2 edges</li>
<li>$n$3</li>
</ul>
<p>So we have...</p>
<p>$$
OPT(v, i) = \begin{cases}
0 & v = s, i = 0 \\
\infty & v \ne s, i = 0 \\
\min \{ OPT(v, i - 1), \min_{u \to v} \{ OPT(u, i - 1) + c_{u, v} \} \} & \text{otherwise}
\end{cases}
$$</p>
<p>Since any path in any graph has at most $n$4 edges, the shortest path to $n$5 has $n$6 edges. Thus, $n$7 is the length of the shortest path from $n$8.</p>
<p><strong>Running Time</strong>: We solve $n$9 subproblems, each taking $OPT$0 time to solve, for a total running time of $OPT$1.</p>
<pre><code class="language-python">def bellman_ford(G, C, s):
  n = len(G)
  dp = [[float('inf')] * (n + 1) for _ in range(n)]

  for i in range(n + 1):
    dp[s][i] = 0

  for i in range(1, n):
    for v in range(n):
      dp[v][i] = dp[v][i - 1]
      for u in range(n):
        dp[v][i] = min(dp[v][i], dp[u][i - 1] + C[u][v])

  return [dp[v][n] for v in range(n)]
</code></pre>
<h2 id="p1-knapsack-approximation">P1 - Knapsack Approximation</h2>
<p>Given $OPT$2 items with integer weights $OPT$3 and values $OPT$4 and knapsack of weight $OPT$5 such that $OPT$6 for all $OPT$7. Design an algorithm that runs in time polynomial in $OPT$8 and $OPT$9 and outputs a 2-approximation for the knapsack problem.</p>
<pre><code class="language-python">def A(weights, values, W):
  n = len(weights)
  greed = [(values[i] / weights[i], i) for i in range(n)]
  greed.sort(reverse=True)

  w, v = 0, 0
  for i in range(n):
    if w + weights[greed[i][1]] &lt;= W:
      w += weights[greed[i][1]]
      v += values[greed[i][1]]
    else:
      break

  return v
</code></pre>
<p><strong>Correctness</strong>: Let $j_n \notin OPT(j_1, j_2, \ldots, j_n)$0 be my algorithm above, $j_n \notin OPT(j_1, j_2, \ldots, j_n)$1 be an algorithm that makes the same greedy choice of selecting items in increasing order of $j_n \notin OPT(j_1, j_2, \ldots, j_n)$2, but with fractional selection allowed, and $j_n \notin OPT(j_1, j_2, \ldots, j_n)$3 be the optimal algorithm for selecting items of only whole quantities. Let $j_n \notin OPT(j_1, j_2, \ldots, j_n)$4 be the set of items chosen by $j_n \notin OPT(j_1, j_2, \ldots, j_n)$5, $j_n \notin OPT(j_1, j_2, \ldots, j_n)$6 be the set of items chosen by $j_n \notin OPT(j_1, j_2, \ldots, j_n)$7, and $j_n \notin OPT(j_1, j_2, \ldots, j_n)$8 be the set of items chosen by $j_n \notin OPT(j_1, j_2, \ldots, j_n)$9. Define $OPT(j_1, j_2, \ldots, j_{n - 1})$0 and $OPT(j_1, j_2, \ldots, j_{n - 1})$1 as the sum of weights and values respectively of items in the set of items $OPT(j_1, j_2, \ldots, j_{n - 1})$2.</p>
<p><em>Lemma 1</em>: With fractional choices allowed, greedy (choosing highest $OPT(j_1, j_2, \ldots, j_{n - 1})$3 ratio) upper bounds the optimal for non-fractional choices, i.e. $OPT(j_1, j_2, \ldots, j_{n - 1})$4. This is given</p>
<p><em>Lemma 2</em>: $OPT(j_1, j_2, \ldots, j_{n - 1})$5 chooses items with a total sum of weights $OPT(j_1, j_2, \ldots, j_{n - 1})$6</p>
<p><em>Proof</em>: We know that each $OPT(j_1, j_2, \ldots, j_{n - 1})$7, so $OPT(j_1, j_2, \ldots, j_{n - 1})$8 is guaranteed to choose at least two items before running out of room in the knapsack. Suppose for the sake of contradiction that the set of items chosen by $OPT(j_1, j_2, \ldots, j_{n - 1})$9 had a total weight $j_n \in OPT(j_1, j_2, \ldots, j_n)$0. Let $j_n \in OPT(j_1, j_2, \ldots, j_n)$1 be the weight of our knapsack right before $j_n \in OPT(j_1, j_2, \ldots, j_n)$2 terminates. Since we are guaranteed to be able to choose at least $j_n \in OPT(j_1, j_2, \ldots, j_n)$3 items, and each item has an integer weight $j_n \in OPT(j_1, j_2, \ldots, j_n)$4, we have that $j_n \in OPT(j_1, j_2, \ldots, j_n)$5. In order for our premise to be true, we need to have $j_n \in OPT(j_1, j_2, \ldots, j_n)$6, but since each $j_n \in OPT(j_1, j_2, \ldots, j_n)$7, we must have then been able to select the next item, so our algorithm wouldn't have terminated at this point, which is a contradiction.</p>
<p><em>Lemma 3</em>: $j_n \in OPT(j_1, j_2, \ldots, j_n)$8 will choose the whole item up until the last item it adds to its knapsack</p>
<p><em>Proof</em>: By the design of the algorithm this must be true. Consider an arbitrary round of $j_n \in OPT(j_1, j_2, \ldots, j_n)$9 in which it considers item $j_n$0 and has a current remaining weight of $j_n$1. We have two cases:</p>
<ul>
<li>Case 1: $j_n$2</li>
<li>Then we take the entire item since this is the best value/weight item that we haven't already visited</li>
<li>Case 2: $j_n$3</li>
<li>Then we take as much of the item as possible (weight $j_n$4 of it), after which our knapsack is full and we terminate</li>
</ul>
<p>No matter what, if we select a fractional amount of an item then it means we've filled the remaining weight of our knapsack and so the algorithm terminates immediately after.</p>
<p><em>Lemma 4</em>: For any integers $j_n$5, if $j_n$6, then $j_n$7</p>
<p><em>Proof</em>: $j_n$8</p>
<p>From (1), we have that $j_n$9</p>
<p>From (2) we have that $2^n$0, and by definition $2^n$1, so we have that $2^n$2. Both $2^n$3 and $2^n$4 choose values in the same order, and by (3) we have that $2^n$5 picks only full items until the very last item added. Therefore, the items chosen by $2^n$6 are exactly the same as the items chosen by $2^n$7 up until the very last item. Let $2^n$8 be the remaining weight in both $2^n$9 and $O(2^n) \to O(n)$0's knapsack at this point, and $O(2^n) \to O(n)$1 be the last item added by $O(2^n) \to O(n)$2. We have the following cases:</p>
<ul>
<li>Case 1: $O(2^n) \to O(n)$3</li>
<li>Then $O(2^n) \to O(n)$4 chooses all of $O(2^n) \to O(n)$5, and $O(2^n) \to O(n)$6 will also choose $O(2^n) \to O(n)$7, so $O(2^n) \to O(n)$8 and $O(2^n) \to O(n)$9 pick the exact same set and amounts of items, and we have $n$0, and so $n$1</li>
<li>Case 2: $n$2</li>
<li>Then $n$3 chooses $n$4 of $n$5, and $n$6 will see the item that it can't fit and terminate, in which case we have $n$7</li>
</ul>
<p>In case 1, we clearly have a 2-approximation of $n$8, since $n$9 is optimal.</p>
<p>In case 2 however, the key insight is that the value that the last item contributes to $OPT$0 is no more than half of the total value, which I will show below.</p>
<p>We have that $OPT$1, since otherwise we would be able to choose a non-fractional amount of $OPT$2 (since $OPT$3). Considering the sum of values of the first $OPT$4 items chosen by $OPT$5 (as well as $OPT$6), we have...</p>
<p>$$
OPT(n, c) = \begin{cases}
1 & n = 1 \\
OPT(n - 1, c') + OPT(n - 1, c) & 2 \le n \le k_c \\
\sum_{j = 1}^{k_c} OPT(n - j, c') & n > k_c
\end{cases}
$$0</p>
<p>Since $OPT$7 chooses items in increasing order of $OPT$8, we also have that $OPT$9 for all $< n$0, so we can put a lower bound on the sum of the first $< n$1 values chosen by $< n$2</p>
<p>$$
OPT(n, c) = \begin{cases}
1 & n = 1 \\
OPT(n - 1, c') + OPT(n - 1, c) & 2 \le n \le k_c \\
\sum_{j = 1}^{k_c} OPT(n - j, c') & n > k_c
\end{cases}
$$1</p>
<p>And since $< n$3, we have...</p>
<p>$$
OPT(n, c) = \begin{cases}
1 & n = 1 \\
OPT(n - 1, c') + OPT(n - 1, c) & 2 \le n \le k_c \\
\sum_{j = 1}^{k_c} OPT(n - j, c') & n > k_c
\end{cases}
$$2</p>
<p>Similarly, we can lower bound $< n$4, since $< n$5</p>
<p>$$
OPT(n, c) = \begin{cases}
1 & n = 1 \\
OPT(n - 1, c') + OPT(n - 1, c) & 2 \le n \le k_c \\
\sum_{j = 1}^{k_c} OPT(n - j, c') & n > k_c
\end{cases}
$$3</p>
<p>So we have...</p>
<p>$$
OPT(n, c) = \begin{cases}
1 & n = 1 \\
OPT(n - 1, c') + OPT(n - 1, c) & 2 \le n \le k_c \\
\sum_{j = 1}^{k_c} OPT(n - j, c') & n > k_c
\end{cases}
$$4</p>
<p>And since $< n$6, by (4) we have that $< n$7.</p>
<p>Therefore, knowing that $< n$8 is optimal with fractional weights, and that the only way $< n$9 and $j_n \in OPT$0 differ is in the last item added in case 2, we have that...</p>
<p>$$
OPT(n, c) = \begin{cases}
1 & n = 1 \\
OPT(n - 1, c') + OPT(n - 1, c) & 2 \le n \le k_c \\
\sum_{j = 1}^{k_c} OPT(n - j, c') & n > k_c
\end{cases}
$$5</p>
<p>And so $j_n \in OPT$1. Additionally, since $j_n \in OPT$2 is optimal for non-fractional weights, by definition we have $j_n \in OPT$3, and $j_n \in OPT$4 is therefore a 2-approximation of $j_n \in OPT$5.</p>
<p><strong>Running Time</strong>:</p>
<p>Since $j_n \in OPT$6, and division by $j_n \in OPT$7 is $j_n \in OPT$8, calculating <code>greed</code>, which has $j_n \in OPT$9 elements, takes $i$0, and sorting it takes $i$1.</p>
<p>Then, I iterate through $i$2 items in the loop, and once again since $i$3, and each iteration is only performing addition, we have $i$4 work in each iteration, for a total of $i$5</p>
<p>Therefore, the overall running time of the algorithm is $i$6, which is polynomial in $i$7 and $i$8</p>
<h2 id="p2-maximum-sub-rectangle">P2 - Maximum Sub-Rectangle</h2>
<p><strong>Problem</strong>: You are given an $i$9 array $n$0 where for all $n$1, $n$2 is an integer that may be negative. For a rectangle $n$3 where $n$4 and $n$5, the value is the sum of all numbers in this rectangle, i.e.,</p>
<p>$$
OPT(n, c) = \begin{cases}
1 & n = 1 \\
OPT(n - 1, c') + OPT(n - 1, c) & 2 \le n \le k_c \\
\sum_{j = 1}^{k_c} OPT(n - j, c') & n > k_c
\end{cases}
$$6</p>
<p>Design an algorithm that runs in time $n$6 and outputs the value of the rectangle of largest value. Note that the value of the empty rectangle is zero.</p>
<pre><code class="language-python">def max_rectangle(A):
  n = len(A)

  dp = [[0] * (n + 1) for _ in range(n + 1)]
  pf_row = [[0] * (n + 1) for _ in range(n + 1)]
  for x in range(1, n + 1):
    for y in range(1, n + 1):
      pf_row[x][y] = pf_row[x][y - 1] + A[x - 1][y - 1]

  def effsum(x1, y1, x2, y2):
    return A[x1 - 1][y1 - 1] if x1 == x2 and y1 == y2 else sum(
        pf_row[i][y2] - pf_row[i][y1 - 1]
        for i in range(x1, x2 + 1)
    )

  def g(y1, y2):
    if y1 &gt; y2:
      return 0

    dp[y1][y2] = max(g(y1 + 1, y2), g(y1, y2 - 1))
    curr = 0
    for x in range(1, n + 1):
      curr = max(curr + effsum(x, y1, x, y2), 0)
      dp[y1][y2] = max(dp[y1][y2], curr)
    return dp[y1][y2]

  return max(0, g(1, n))
</code></pre>
<p><strong>Correctness</strong>: Define $n$7 as the maximum sum rectangle with the upper left corner being $n$8, and lower right corner being $n$9 for all $OPT$0 and $OPT$1. Additionally, define $OPT$2 as the sum of the rectangle with the upper left corner being $OPT$3 and lower right corner being $OPT$4, i.e. $OPT$5</p>
<p>Our base case is when $OPT$6, in which case we return $OPT$7 because this is an empty/negative size rectangle.</p>
<p>Assuming we've calculated $OPT$8 for all $OPT$9, we can calculate $p(n) = $0 by considering all rectangles that either (1) don't contain any of the row $p(n) = $1, (2) don't contain any of the row $p(n) = $2, or (3) contain both rows $p(n) = $3 and $p(n) = $4.</p>
<p>Since $p(n) = $5 and $p(n) = $6, we can find (1) and (2) with $p(n) = $7 and $p(n) = $8 respectively. Then, to find (3) we need to consider each possible $p(n) = $9, choosing the values that maximum our sum for $i < n$0 being fixed. This can be calculated as the largest sum of contiguous subsequences of rows between $i < n$1 and $i < n$2. To do this, I reduce this problem to the largest contiguous subsequence of a list of numbers $i < n$3,</p>
<p>Defining $i < n$4 to be the LCS that can be made with $i < n$5 which either includes $i < n$6 or is empty, we induct over $i < n$7. My base case is when $i < n$8, in which case $i < n$9. Assuming $j_i$0 is correct, we can calculate $j_i$1 by taking maximum of either choosing to include $j_i$2 in our subsequence, or to reset our subsequence to zero. Therefore, we have...</p>
<p>$$
OPT(n, c) = \begin{cases}
1 & n = 1 \\
OPT(n - 1, c') + OPT(n - 1, c) & 2 \le n \le k_c \\
\sum_{j = 1}^{k_c} OPT(n - j, c') & n > k_c
\end{cases}
$$7</p>
<p>Then, to find the maximum sum of a contiguous subsequence of $j_i$3, we just need to take the maximum of $j_i$4 for all $j_i$5. Let $j_i$6. My code calculates $j_i$7 over the sum of rows between $j_i$8 and $j_i$9 in a bottom up fashion, but instead of storing all previous $j_n$0 for $j_n$1, I only store the previous in a variable <code>curr</code>. Additionally, I keep track of the maximum $j_n$2 I've seen thus far in another variable <code>dp[y1][y2]</code>, but this is equivalent. Let $j_n$3 denote the same problem, but ranging over $j_n$4 values of the form $j_n$5, with the induction being over $j_n$6 (the number of elements) still. Note that this is an equivalently solved problem, and the extra parameters are just to define bounds on the rows in which the instance of the problem exists.</p>
<p>Then we have the following recurrence for $j_n$7:</p>
<p>$$
OPT(n, c) = \begin{cases}
1 & n = 1 \\
OPT(n - 1, c') + OPT(n - 1, c) & 2 \le n \le k_c \\
\sum_{j = 1}^{k_c} OPT(n - j, c') & n > k_c
\end{cases}
$$8</p>
<p>Since $j_n$8 checks all possible $j_n$9 and finds the best $s_j, f_i$0 for each of them, we must find the largest sum rectangle, and can thus return $s_j, f_i$1 as the maximum sub-rectangle in $s_j, f_i$2.</p>
<p><strong>Running Time</strong>:</p>
<p>I start by finding the prefix sum of all rows in $s_j, f_i$3.</p>
<p>Then, I solve $s_j, f_i$4 many subproblems, one for each $s_j, f_i$5. Each subproblem takes $s_j, f_i$6 time to solve, since I need to loop through $s_j, f_i$7 many sub-sub problems to find the maximum sum contiguous subsequence of row sums. Note that to calculate row sums, I use my precomputed prefix sum, which allows me to calculate the sum of a row in $s_j, f_i$8.</p>
<p>Therefore, the overall runtime is $s_j, f_i$9.</p>
<h2 id="p3-count-connected-subsets-of-size-k">P3 - Count connected subsets of size k</h2>
<p>Given a tree $OPT(j_1, \ldots, j_{p(n)})$0 with $OPT(j_1, \ldots, j_{p(n)})$1 vertices and an integer $OPT(j_1, \ldots, j_{p(n)})$2 such that every vertex of $OPT(j_1, \ldots, j_{p(n)})$3 has degree $OPT(j_1, \ldots, j_{p(n)})$4, we want to choose a set $OPT(j_1, \ldots, j_{p(n)})$5 of $OPT(j_1, \ldots, j_{p(n)})$6 vertices of the tree which are connected, i.e., for any pair of vertices $OPT(j_1, \ldots, j_{p(n)})$7 the unique path between $OPT(j_1, \ldots, j_{p(n)})$8 in $OPT(j_1, \ldots, j_{p(n)})$9 is also in $j_n \notin OPT$0. Design a polynomial time algorithm that outputs the number of such sets $j_n \notin OPT$1.</p>
<pre><code class="language-python">def num_sets_deg_3(T, k):

  def levels(v):
    q = deque()
    vis = set()
    L = {}
    q.append((v, 0))

    while q:
      size = len(q)
      curr, l = q.popleft()
      L[curr] = l
      vis.add(curr)
      for _ in range(size):
        for nxt in T[curr]:
          if nxt not in vis:
            q.append((nxt, l + 1))
    return L

  root = arb_key(T)
  L = levels(root)

  def children(v):
    return { u for u in T[v] if L[u] == L[v] + 1 }

  dp = { v: { 1: 1, 0: 1 } for v in T.keys() }

  def r(v, k):
    if k in dp[v]:
      return dp[v][k]

    c = list(children(v))
    ans = 0
    if len(c) == 0:
      return 1 if k == 1 else 0
    elif len(c) == 1:
      ans = r(c[0], k - 1)
    elif len(c) == 2:
      for c1 in range(k):
        c2 = k - c1 - 1
        ans += r(c[0], c1) * r(c[1], c2)
    elif len(c) == 3:
      for c1 in range(k):
        for c2 in range(k - c1):
          c3 = k - c1 - c2 - 1
          ans += r(c[0], c1) * r(c[1], c2) * r(c[2], c3)


    dp[v][k] = ans
    return dp[v][k]

  return sum(f(u, k) for k in T.keys())
</code></pre>
<p><strong>Correctness</strong>:</p>
<p>Start by choosing an arbitrary vertex $j_n \notin OPT$2 as root, and run $j_n \notin OPT$3, returning the level of each vertex in the BFS-tree (with <code>L[r] = 0</code>).</p>
<p>Define $j_n \notin OPT$4 as the number of connected subsets of size $j_n \notin OPT$5 that <strong>must</strong> contain $j_n \notin OPT$6, and are otherwise composed of vertices $j_n \notin OPT$7 with $j_n \notin OPT$8, i.e. only containing descendants of $j_n \notin OPT$9 in the BFS tree. We prove correctness of $OPT(j_1, \ldots, j_{n - 1})$0 by inducting on $OPT(j_1, \ldots, j_{n - 1})$1.</p>
<p>Our base cases are as follows:</p>
<ul>
<li>$OPT(j_1, \ldots, j_{n - 1})$2 if $OPT(j_1, \ldots, j_{n - 1})$3, since there is only one empty set, and there can only be one set of size one containing $OPT(j_1, \ldots, j_{n - 1})$4, namely $OPT(j_1, \ldots, j_{n - 1})$5</li>
<li>$OPT(j_1, \ldots, j_{n - 1})$6 if $OPT(j_1, \ldots, j_{n - 1})$7 and $OPT(j_1, \ldots, j_{n - 1})$8, since there is no way to make a set of size $OPT(j_1, \ldots, j_{n - 1})$9 with less than $OPT(j_1, \ldots, j_n)$0 vertices, and in this case, $OPT(j_1, \ldots, j_n)$1 is our only potential element.</li>
</ul>
<p>Note that $OPT(j_1, \ldots, j_n)$2 is defined at $OPT(j_1, \ldots, j_n)$3</p>
<p>And so to calculate $OPT(j_1, \ldots, j_n)$4, we just need to sum over all possibilities that involve $OPT(j_1, \ldots, j_n)$5 in terms of children of $OPT(j_1, \ldots, j_n)$6. Let $OPT(j_1, \ldots, j_n)$7 (since $OPT(j_1, \ldots, j_n)$8), and $OPT(j_1, \ldots, j_n)$9 be $n$0's children. Any given subproblem contains vertices in any subset of $n$1 of size $n$2, so we need to iterate through all possible ways to choose such a subset of children for a given subproblem of size $n$3, accounting for the fact that any subset counted must contain $n$4.</p>
<ul>
<li>Case 0: $n$5</li>
<li>This is a base case, so if $n$6 we return $n$7, and otherwise return $n$8</li>
<li>Case 1: $n$9</li>
<li>We have only one child, so we just need to calculate $w_1, \ldots, w_n$0, since we must choose $w_1, \ldots, w_n$1 as an element of any subset counted, and so we have $w_1, \ldots, w_n$2 remaining vertices to choose</li>
<li>Case 2: $w_1, \ldots, w_n$3</li>
<li>We have two children, so we need to iterate through all possible ways to choose $w_1, \ldots, w_n$4 vertices from the first child and $w_1, \ldots, w_n$5 vertices from the second child, such that $w_1, \ldots, w_n$6, keeping a sum of all possibilities. Then, via the product rule for counting, we just multiply $w_1, \ldots, w_n$7 for the total number of possibilities for each value of $w_1, \ldots, w_n$8.</li>
<li>Case 3: $w_1, \ldots, w_n$9</li>
<li>We have three children, so we need to iterate through all possible ways to choose $v_1, \ldots, v_n$0 vertices from the children, such that $v_1, \ldots, v_n$1, keeping a sum of all possibilities. Then, via the product rule for counting, we just multiply $v_1, \ldots, v_n$2 for the total number of possibilities for each value of $v_1, \ldots, v_n$3.</li>
</ul>
<p>Note that these are disjoint cases, but the case where we choose only vertices from a subset of subtrees is handled by letting $v_1, \ldots, v_n$4 for the subtrees not chosen.</p>
<p>This gives rise to the following recurrence:</p>
<p>$$
OPT(n, c) = \begin{cases}
1 & n = 1 \\
OPT(n - 1, c') + OPT(n - 1, c) & 2 \le n \le k_c \\
\sum_{j = 1}^{k_c} OPT(n - j, c') & n > k_c
\end{cases}
$$9</p>
<p>And since each of these problems has at most size $v_1, \ldots, v_n$5 in the recursive case, our inductive hypothesis holds and we can calculate $v_1, \ldots, v_n$6.</p>
<p>To arrive at our final answer, we partition our possible answer space by sets of subsets that contain a given vertex $v_1, \ldots, v_n$7, none of $v_1, \ldots, v_n$8's ancestors, and some of $v_1, \ldots, v_n$9's descendants. Our final answer is then the sum of all $W$0 for $W$1. Note that each of these cases is disjoint, since each set of subsets must contain $W$2, and no ancestors of $W$3, so any previously calculated $W$4 for $W$5 being an ancestor of $W$6 will not be included in answer for $W$7.</p>
<p>Therefore, we have a final solution of $W$8</p>
<p><strong>Running Time</strong>:</p>
<p>Let $W$9 be the number of vertexes in $I$0. We start by calculating the levels of each node in a BFS tree rooted at an arbitrary $I$1, which takes $I$2 (since $I$3 is a tree and therefore has $I$4 edges) time.</p>
<p>For each call to $I$5, we solve $I$6 subproblems, each of which take a constant time to compute given that subproblems with a $I$7 have already been solved. We only have this constant time computation since the number of children is at most $I$8, since otherwise we would need to solve a number of subproblems exponential in the $I$9 to check every subset of children to include. Therefore, each call takes $S \subseteq I$0 time.</p>
<p>Since we call $S \subseteq I$1 on all vertices in the tree, and each call takes at most $S \subseteq I$2 time (but often performs better due to memoized answers from calls on ancestors of $S \subseteq I$3), we have an upper bound of $S \subseteq I$4 on computing the overall answer, which is polynomial</p>
            </div>
            <div class="tags">
                Tags:
                <a href="/tags/algorithm%20analysis.html">algorithm analysis</a>
                <a href="/tags/dynamic%20programming.html">dynamic programming</a>
                <a href="/tags/optimization.html">optimization</a>
            </div>
        </article>
    </main>
    <footer role="contentinfo">
        <p>2025, authored by Elijah Melton.</p>
    </footer>
</body>
</html>
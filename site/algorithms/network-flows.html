
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Flow Algorithms and Applications in Graph Theory | Elijah's Notes</title>

    <!-- SEO Meta Tags -->
    <meta name="description" content="Comprehensive overview of network flow algorithms, including Max Flow/Min Cut and Ford-Fulkerson. Covers applications in bipartite matching, vertex cover, and independent set problems. Includes proofs, algorithms, and problem-solving techniques for graph theory concepts.">
    <meta name="author" content="Elijah Melton">
    <meta name="robots" content="index, follow">
    <meta name="generator" content="Custom Static Site Generator">
    <link rel="canonical" href="https://notes.elimelt.com/algorithms/network-flows.html">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:title" content="Network Flow Algorithms and Applications in Graph Theory">
    <meta property="og:description" content="Comprehensive overview of network flow algorithms, including Max Flow/Min Cut and Ford-Fulkerson. Covers applications in bipartite matching, vertex cover, and independent set problems. Includes proofs, algorithms, and problem-solving techniques for graph theory concepts.">
    <meta property="og:url" content="https://notes.elimelt.com/algorithms/network-flows.html">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Network Flow Algorithms and Applications in Graph Theory">
    <meta name="twitter:description" content="Comprehensive overview of network flow algorithms, including Max Flow/Min Cut and Ford-Fulkerson. Covers applications in bipartite matching, vertex cover, and independent set problems. Includes proofs, algorithms, and problem-solving techniques for graph theory concepts.">

    <meta name="keywords" content="max flow min cut,ford-fulkerson algorithm,bipartite matching,vertex cover,independent set">

    <!-- Schema.org JSON-LD -->
    <script type="application/ld+json">
    {"@context": "https://schema.org", "@type": "Article", "headline": "Network Flow Algorithms and Applications in Graph Theory", "dateModified": "2025-01-01T04:22:56.060790", "description": "Comprehensive overview of network flow algorithms, including Max Flow/Min Cut and Ford-Fulkerson. Covers applications in bipartite matching, vertex cover, and independent set problems. Includes proofs, algorithms, and problem-solving techniques for graph theory concepts.", "articleSection": "Graph Theory", "keywords": "max flow min cut,ford-fulkerson algorithm,bipartite matching,vertex cover,independent set"}
    </script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/contrib/auto-render.min.js"></script>

    <!-- Configure KaTeX auto-render -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$", right: "$", display: true},
                    {left: "\\[", right: "\\]", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false}
                ],
                throwOnError: false
            });
        });
    </script>

<style>
    :root {
        --text-color: #1a1a1a;
        --background-color: #ffffff;
        --accent-color: #2563eb;
        --border-color: #e5e7eb;
        --nav-background: rgba(255, 255, 255, 0.95);
    }

    @media (prefers-color-scheme: dark) {
        :root {
            --text-color: #f3f4f6;
            --background-color: #1a1a1a;
            --accent-color: #60a5fa;
            --border-color: #374151;
            --nav-background: rgba(26, 26, 26, 0.95);
        }
    }

    body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        line-height: 1.6;
        max-width: 50rem;
        margin: 0 auto;
        padding: 2rem;
        color: var(--text-color);
        background: var(--background-color);
    }

    nav {
        position: sticky;
        top: 0;
        background: var(--nav-background);
        backdrop-filter: blur(10px);
        border-bottom: 1px solid var(--border-color);
        padding: 1rem 0;
        margin-bottom: 2rem;
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        z-index: 1000;
    }

    nav a {
        color: var(--accent-color);
        text-decoration: none;
        padding: 0.5rem 1rem;
        border-radius: 4px;
        transition: background-color 0.2s;
    }

    nav a:hover {
        background-color: var(--border-color);
    }

    .breadcrumbs {
        margin-bottom: 2rem;
        color: var(--text-color);
        opacity: 0.8;
    }

    .breadcrumbs a {
        color: var(--accent-color);
        text-decoration: none;
    }

    .content {
        margin-top: 2rem;
    }

    h1, h2, h3, h4, h5, h6 {
        margin-top: 2rem;
        margin-bottom: 1rem;
        line-height: 1.3;
    }

    code {
        background: var(--border-color);
        padding: 0.2rem 0.4rem;
        border-radius: 3px;
        font-size: 0.9em;
        font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
    }

    pre {
        background: var(--border-color);
        padding: 1rem;
        border-radius: 4px;
        overflow-x: auto;
        margin: 1.5rem 0;
    }

    pre code {
        background: none;
        padding: 0;
        border-radius: 0;
    }

    img {
        max-width: 100%;
        height: auto;
        border-radius: 4px;
        margin: 1.5rem 0;
    }

    .meta {
        color: var(--text-color);
        opacity: 0.8;
        font-size: 0.9em;
        margin-bottom: 2rem;
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
    }

    .tags {
        margin-top: 2rem;
        padding-top: 1rem;
        border-top: 1px solid var(--border-color);
    }

    .tags a {
        display: inline-block;
        background: var(--border-color);
        color: var(--text-color);
        padding: 0.2rem 0.6rem;
        border-radius: 3px;
        text-decoration: none;
        font-size: 0.9em;
        margin-right: 0.5rem;
        margin-bottom: 0.5rem;
    }

    .tags a:hover {
        background: var(--accent-color);
        color: white;
    }

    a {
        color: #3391ff;
    }

    table {
        width: 100%;
        border-collapse: collapse;
        margin: 1.5rem 0;
    }

    th, td {
        padding: 0.75rem;
        border: 1px solid var(--border-color);
    }

    th {
        background: var(--border-color);
    }

    .md-content table td, .md-content table th {
        background: black;
    }

    blockquote {
        margin: 1.5rem 0;
        padding-left: 1rem;
        border-left: 4px solid var(--accent-color);
        color: var(--text-color);
        opacity: 0.8;
    }

    .katex-display {
        overflow: auto hidden;
        padding: 1em 0;
        margin: 0.5em 0;
    }

    .katex-display > .katex {
        white-space: normal;
    }

    .katex {
        font-size: 1.1em;
        display: inline;
        line-height: 1.2;
    }

    .katex-html {
        display: inline-block;
        vertical-align: middle;
    }

    .katex .strut {
        display: none;
    }

    .katex-display .katex {
        display: block;
        text-align: center;
    }

    .katex-display > .katex > .katex-html {
        display: block;
        max-width: 100%;
        overflow-x: auto;
        padding: 0.5em 0;
        min-height: 40px;
    }
</style></head>
<body>
    <header>
        <nav role="navigation" aria-label="Main navigation">
            <a href="/index.html">Home</a>
<a href="/categories/index.html">Categories</a>
<a href="/tags/index.html">Tags</a>
        </nav>
        <div class="breadcrumbs" role="navigation" aria-label="Breadcrumb">
            <a href="/index.html">Home</a> » <a href="/categories/graph%20theory.html">Graph Theory</a> » Network Flow Algorithms and Applications in Graph Theory
        </div>
    </header>
    <main role="main">
        <article>
            <h1>Network Flow Algorithms and Applications in Graph Theory</h1>
            <div class="meta">
                <time datetime="2025-01-01T04:22:56.060790">
                    Last modified: 2025-01-01
                </time>
                <span>Category: <a href="/categories/graph%20theory.html">Graph Theory</a></span>
            </div>
            <div class="content">
                <h1 id="network-flow-max-flow-and-min-cut">Network Flow - Max Flow and Min Cut</h1>
<h2 id="max-flowmin-cut">Max Flow/Min Cut</h2>
<p><strong>Max Flow</strong> and <strong>Min Cut</strong> are two important concepts in graph theory with wide reaching applications. Many problems are reduced to either of them, such as...</p>
<ul>
<li><strong>Transportation Networks</strong>: flow of goods, data, or people through a network, i.e. all kinds of traffic flow </li>
<li><strong>Telecommunications</strong>: flow of data through a network. Min cut is exactly the number of edges you need to remove to fully disconnect servers $s$ and $t$</li>
<li><strong>Image Segmentation</strong>: partitioning an image into regions</li>
<li><strong>Data Mining</strong>: clustering and classification</li>
</ul>
<p>Typically, you use min cut when you are looking for some partition of objects into two sets such that some cost is minimized. You use max flow typically in problems involving optimal routing. Note that if there is some natural ordering associated with objects, you should also try dynamic programming. Additionally, problems on trees can sometimes be solved with greedy (using induction on the leaves), or dynamic programming on sub-trees.</p>
<p>Given a graph $G$ and vertices $s, t$, the min flow/max cut problem is to find the minimum capacity of a flow from $s$ to $t$ in the graph. This is equivalent to finding the maximum capacity of a cut that separates $s$ from $t$.</p>
<p>We have the following definitions:</p>
<ul>
<li>Given a cut $(A, B)$, the capacity, $cap(A, B) = \sum_{u \in A, v \in B, (u, v) \in E} c(u, v)$</li>
</ul>
<h2 id="ford-fulkerson-algorithm">Ford Fulkerson Algorithm</h2>
<p>The Ford Fulkerson algorithm is a method for solving the min flow/max cut problem. An <strong>augmenting path</strong> is a path from $s$ to $t$ in the residual graph $G_f$ with positive capacity. The algorithm works by finding augmenting paths and increasing the flow along them until no more augmenting paths exist. Once no more augmenting paths exist, the flow is at its maximum, and the minimum cut is found by finding the set of vertices reachable from $s$ in the residual graph.</p>
<p>A residual graph $G_f$ is a graph that represents the remaining capacity of edges in the original graph. If an edge $(u, v)$ has capacity $c$, and $f(u, v)$ is the flow along that edge, then the residual capacity is $c - f(u, v)$. We represent residual edges as an edge traversable in the opposite direction to the way capacity flows, and keep a forward edge for the remaining capacity.</p>
<p>If all edges along an augmenting path are in the forward direction, we can increase the flow by the minimum capacity of the path, updating the residual graph accordingly.</p>
<p>On the other hand, if an edge is in the reverse direction, we can decrease the flow along that edge by the minimum capacity of the path. This is equivalent to increasing the flow along the reverse edge.</p>
<pre><code class="language-python">def augment(G, f, c, P):
  min_cap = min(c[u][v] - f[u][v] for u, v in P)
  for u, v in P:
    if v in G[u]:
      f[u][v] += min_cap
      c[u][v] -= min_cap
      c[v][u] += min_cap
    else:
      f[v][u] -= min_cap
      c[v][u] += min_cap
      c[u][v] -= min_cap
  return f

def find_augmenting_path(G, s, t):
  stack = [(s, [s])]
  while stack:
    curr, path = stack.pop()
    if curr == t:
      return path
    for v in G[curr]:
      if v in path:
        continue
      stack.append((v, path + [v]))
  return None

def ford_fulkerson(G, s, t, c):
  Gf = {u: {v for v in G[u]} for u in G}
  f = {u: {v: 0 for v in G[u]} for u in G}

  while True:
    P = find_augmenting_path(Gf, s, t)
    if not P:
      break
    f = augment(G, f, c, P)
  return f
</code></pre>
<h3 id="running-time">Running Time</h3>
<p>Assume that all capacities are integers between $1$ and $C$. Invariantly, every flow value $f(e)$ and every residual capacity $c_f(e)$ remains an integer throughout the algorithm.</p>
<p><strong>Theorem</strong>: The algorithm terminates after at most $v(f^*) < nC$, if $f^*$ is an optimal flow.</p>
<p>This is because only one vertex ($S$) actually produces flow. Therefore, we have a tight upper bound on $v(f^*)$ of $(n - 1)C$. Each iteration of the algorithm increases the value of the flow by at least $1$ (since flows are integers).</p>
<p>Since at each iteration, we need to find an augmenting path via DFS, we have an overall runtime of $O(mnC)$, or more generally, $O(mv(f^*))$</p>
<h2 id="maximum-matching">Maximum Matching</h2>
<p>Given an undirected graph $G = (V, E)$, find the matching $M \subseteq E$ with largest cardinality. Note that in a matching is a set of edges where each vertex touches at most one edge in $M$.</p>
<p>In general, you can solve this in polynomial time, but I won't go into detail. Instead, I cover the case where $G$ is bipartite.</p>
<h3 id="bipartite-maximum-matching">Bipartite Maximum Matching</h3>
<p>Given an undirected bipartite graph $G = (X \cup Y, E)$, find the maximum matching $s$0.</p>
<p>Add vertices $s$1, with edges $s$2 of capacity $s$3 for $s$4, and $s$5 of capacity $s$6 for $s$7. All other edges have weight $s$8. Orient all edges from $s$9, i.e. all edges between $t$0 and $t$1 have direction $t$2.</p>
<p>Find the maximum flow from $t$3. The maximum flow is the maximum matching, and the minimum cut is the minimum vertex cover.</p>
<p><strong>Proof</strong>: Let $t$4 be a matching in $t$5, and $t$6 be the value of the maximum <strong>integer</strong> flow some $t$7 in the constructed graph. We need to prove $t$8.</p>
<p>$t$9: We need to find some flow that satisfies the preceding constraint. Since all flows are a candidate for max flow, and the max flow must be $G$0 any other, showing any flow satisfies it is sufficient.</p>
<ul>
<li>For every edge $G$1, set $G$2, and the rest to $G$3.</li>
<li>The flow is feasible since $G$4, and the conservation of flow holds.</li>
<li>$G$5 total capacity out of $G$6.</li>
</ul>
<p>$G$7: We need to use $G$8 to construct a matching $G$9.</p>
<ul>
<li>Since all capacities of edges are integers, such an $s, t$0 exists.</li>
<li>Since $s, t$1, $s, t$2. Further, each vertex in $s, t$3 takes at most $s, t$4 unit of flow from $s, t$5, and each vertex in $s, t$6 can output at most $s, t$7 unit of flow.</li>
<li>Each path can support up to $s, t$8 unit of flow, and all of them are of the form $s, t$9, for vertices $s$0. Therefore, with a max flow value $s$1, we can create a matching $s$2, where each edge $s$3 corresponds to a unique path of our flow.</li>
<li>So we have a matching with $s$4, meaning $s$5.</li>
</ul>
<h2 id="foregroundbackground-segmentation">Foreground/Background Segmentation</h2>
<p>Label each pixel of an image as foreground or background. $s$6 set of pixels, and $s$7 neighboring pixels.</p>
<ul>
<li>$s$8 is the likelihood of pixel $s$9 being in the foreground</li>
<li>$t$0 is the likelihood of pixel $t$1 being in the background</li>
<li>
<p>$t$2 is the penalty for labeling one of $t$3 and $t$4 as foreground and the other as background, i.e. the penalty for boundaries of the the two regions</p>
</li>
<li>
<p><strong>Accuracy</strong>: If $t$5 in isolation, prefer to label $t$6 in the foreground.</p>
</li>
<li><strong>Smoothness</strong>: If many neighbors of $t$7 are labeled foreground, we should be inclined to label $t$8 as foreground as well.</li>
</ul>
<p>Find a partition $t$9 that maximizes...</p>
<p>$$
\sum_{i \in A} a_i + \sum_{j \in B} b_j - \sum_{(i, j) \in E, i \in A, j \in B} p_{i, j}
$$</p>
<p>We proceed to a solution that uses min-cut. Since this is a maximization problem, but min-cut is a minimization problem, we can just multiply our scoring function by $s$0, so we are now trying to minimize...</p>
<p>$$
\sum_{(i, j) \in E, i \in A, j \in B} p_{i, j} - \sum_{i \in A} a_i - \sum_{j \in B} b_j
$$</p>
<p>Additionally, working with negatives sucks, so we can get rid of them by adding a constant value to make our function positive.</p>
<p>$$
\sum_{(i, j) \in E, i \in A, j \in B} p_{i, j} - \sum_{i \in A} a_i - \sum_{j \in B} b_j + \sum_{i \in V} a_i + \sum_{j \in V} b_j
$$</p>
<p>Since $s$1 and $s$2, it is equivalent to...</p>
<p>$$
\sum_{(i, j) \in E, i \in A, j \in B} p_{i, j} + \sum_{i \in B} a_i + \sum_{j \in A} b_j
$$</p>
<p>Add vertices $s$3 and $s$4, with an edge weight of $s$5 between all edges $s$6, and an edge $s$7 with a weight of $s$8. Then, make all edges $s$9 have a weight $t$0. Then the min-cut of this graph would be the minimization of our objective function, giving us the optimal sets $t$1.</p>
<h2 id="p1-count-disjoint-paths">P1 - Count Disjoint Paths</h2>
<p>Given an undirected graph $t$2 and a set of vertices $t$3 and a disjoint set of vertices $t$4 , i.e., $t$5. Design a polynomial time algorithm that outputs the maximum number of vertex disjoint paths between vertices of $t$6 and $t$7 (note that every vertex in $t$8 and every vertex in $t$9 can be in at most one path).</p>
<p><strong>Algorithm</strong>:</p>
<ul>
<li>Given $(A, B)$0, and $(A, B)$1</li>
<li>Construct a directed graph $(A, B)$2 with all undirected edges $(A, B)$3 corresponding to two directed edges $(A, B)$4. Additionally, add two vertices $(A, B)$5, $(A, B)$6 to $(A, B)$7, and an edge $(A, B)$8 and $(A, B)$9 for all $cap(A, B) = \sum_{u \in A, v \in B, (u, v) \in E} c(u, v)$0, $cap(A, B) = \sum_{u \in A, v \in B, (u, v) \in E} c(u, v)$1.</li>
<li>Run the algorithm from section for the maximum number of vertex disjoint paths in an unweighted directed graph given $cap(A, B) = \sum_{u \in A, v \in B, (u, v) \in E} c(u, v)$2.</li>
</ul>
<p><strong>Correctness</strong>:</p>
<p>Let $cap(A, B) = \sum_{u \in A, v \in B, (u, v) \in E} c(u, v)$3 be an undirected graph, and $cap(A, B) = \sum_{u \in A, v \in B, (u, v) \in E} c(u, v)$4, $cap(A, B) = \sum_{u \in A, v \in B, (u, v) \in E} c(u, v)$5 be disjoint subsets of $cap(A, B) = \sum_{u \in A, v \in B, (u, v) \in E} c(u, v)$6.</p>
<p>Since we have an algorithm from section to find the number of vertex disjoint paths from $cap(A, B) = \sum_{u \in A, v \in B, (u, v) \in E} c(u, v)$7 to $cap(A, B) = \sum_{u \in A, v \in B, (u, v) \in E} c(u, v)$8 in a directed graph containing vertices $cap(A, B) = \sum_{u \in A, v \in B, (u, v) \in E} c(u, v)$9, $s$0, I will just show that I can construct such a directed graph $s$1 from $s$2, and that the number of vertex disjoint paths in $s$3 from $s$4 to $s$5 is equal to the number of vertex disjoint paths in $s$6 from vertices in $s$7 to vertices in $s$8.</p>
<p>My algorithm first adds both a forward and backward directed edge for every edge in $s$9, since $t$0 is undirected and we therefore need to consider paths taking either direction of each directed edge. Note that the vertices of each path considered by the algorithm from section must be disjoint (not counting $t$1 and $t$2), so only one of these edges will ever be used in a path counted by the algorithm in section, so it is safe to add these additional edges without ever counting additional paths.</p>
<p>Furthermore, I add two vertices $t$3 and $t$4 to $t$5, and add a directed edge from $t$6 to every vertex in $t$7, and a directed edge from every vertex in $t$8 to $t$9. This is to form a bijection between $G_f$0, the maximal set of vertex disjoint paths I find in $G_f$1 from $G_f$2, and $G_f$3, the maximal set of vertex disjoint paths that start at a vertex in $G_f$4 and end at a vertex in $G_f$5. In particular, letting $G_f$6 and $G_f$7 be arbitrary vertices from their respective sets, we have paths of the following forms:</p>
<ul>
<li>$G_f$8 for all paths $G_f$9</li>
<li>$s$0 for all paths $s$1</li>
</ul>
<p>All paths in $s$2 must have some $s$3 as their second vertex, since the only edges leaving $s$4 are those going to vertices in $s$5. Similarly, all paths in $s$6 must have their second-to-last vertex as some $s$7, since the only edges incident to $s$8 are those coming from vertices in $s$9.</p>
<p>By definition of the algorithm from section, paths in $G_f$0 are vertex disjoint not counting $G_f$1 and $G_f$2, and $G_f$3 contains the maximal number of such existing paths, or in other words, there are no additional vertex disjoint paths from $G_f$4 that can be added, nor other ways to choose vertex disjoint paths to end up with a larger set $G_f$5.</p>
<p>Therefore, by creating the set $G_f$6 by taking each $G_f$7 and removing the starting and ending vertices $G_f$8 and $G_f$9, we also have vertex disjoint paths, since removing elements of disjoint sets will never make them not disjoint. Furthermore, since $(u, v)$0 is of maximal size, there could not exist any other paths from $(u, v)$1 that would be vertex disjoint. Therefore, for $(u, v)$2 to be maximal sized, we must have $(u, v)$3. To show this more concretely, I will show that $(u, v)$4 and $(u, v)$5.</p>
<ul>
<li>
<p>$(u, v)$6: Since $(u, v)$7 is the maximal set of vertex disjoint paths from $(u, v)$8, there can be no additional paths that are vertex disjoint with the paths in $(u, v)$9, nor any greater such sets. Suppose for the sake of contradiction that $c$0. Then, we can construct a set $c$1 with $c$2 by adding $c$3 to the beginning of each path in $c$4, and $c$5 to the end of each path in $c$6. We are able to do this because we added an edge from $c$7 for $c$8 and $c$9 for $f(u, v)$0. However, we would then have found a set of vertex disjoint paths from $f(u, v)$1 that is larger than $f(u, v)$2, which is a contradiction to $f(u, v)$3 being maximal.</p>
</li>
<li>
<p>$f(u, v)$4: Suppose for the sake of contradiction that $f(u, v)$5. Since we defined $f(u, v)$6 as the maximal set of vertex disjoint paths between vertices in $f(u, v)$7 and $f(u, v)$8, we must not be able to find a greater set $f(u, v)$9. However, if $c - f(u, v)$0, we could construct a set $c - f(u, v)$1 as follows: for each path $c - f(u, v)$2, remove the first and last vertex to make $c - f(u, v)$3. Since each $c - f(u, v)$4 was vertex disjoint, each $c - f(u, v)$5 will also be vertex disjoint, and so we've created a set of vertex disjoint paths from vertices in $c - f(u, v)$6 to vertices in $c - f(u, v)$7 (since the second and second to last vertices of $c - f(u, v)$8 must be in $c - f(u, v)$9 and $1$0 respectively). Therefore, $1$1 was not maximal, and we have a contradiction.</p>
</li>
</ul>
<p><strong>Running Time</strong>: We can construct $1$2 in $1$3, since we only need to visit each edge of each vertex in our graph for duplicating/orienting edges, and an additional $1$4 to add $1$5, $1$6, and edges to vertices in $1$7 and $1$8. Then, we simply need to run the algorithm from section, which takes $1$9, so our total running time is $C$0, which is polynomial.</p>
<h2 id="p2-number-of-disjoint-paths">P2 - Number of Disjoint Paths</h2>
<p>Given a directed unweighted graph $C$1. Suppose that there are $C$2 edge disjoint paths from $C$3 to $C$4 and there are $C$5 edge disjoint paths from $C$6 to $C$7 for vertices $C$8 . Prove that there are $C$9 edge disjoint paths from $f(e)$0 to $f(e)$1.</p>
<p><strong>Proof</strong>:</p>
<p>Let $f(e)$2 be a directed unweighted graph, and $f(e)$3 be vertices such that there are $f(e)$4 edge disjoint paths from $f(e)$5 and $f(e)$6 edge disjoint paths from $f(e)$7. We wish to show that there are $f(e)$8 edge disjoint paths from $f(e)$9.</p>
<p>Construct a graph $c_f(e)$0 by adding vertices $c_f(e)$1 with edges $c_f(e)$2, each having capacity $c_f(e)$3, and the rest of the edges having capacity $c_f(e)$4. We have a maximum flow of $c_f(e)$5 from $c_f(e)$6, since each added edge can support a flow of up to $c_f(e)$7, and we can send $c_f(e)$8 unit of the $c_f(e)$9 flow going into $v(f^*) < nC$0 through the $v(f^*) < nC$1 edge-disjoint paths from $v(f^*) < nC$2 to $v(f^*) < nC$3, and then all $v(f^*) < nC$4 units of flow going into $v(f^*) < nC$5 through the edge $v(f^*) < nC$6. Similarly, we have a max flow from $v(f^*) < nC$7 of $v(f^*) < nC$8, since we can send $v(f^*) < nC$9 units of flow from $f^*$0 into $f^*$1, and then $f^*$2 unit of flow from $f^*$3 into $f^*$4 through the $f^*$5 edge disjoint paths from $f^*$6 to $f^*$7, and then all $f^*$8 units of flow from $f^*$9 into $S$0. Notice that the conservation of flow holds for all of these vertices, since $S$1 receives and outputs $S$2 units of flow, as does $S$3 and $S$4, and the remaining vertices each receive and output $S$5 unit of flow.</p>
<p>Now, in order to show that there are at least $S$6 edge disjoint paths from $S$7, we need to find a flow that sends $S$8 units of flow from $S$9, and equivalently, directly from $v(f^*)$0. Since there are at least $v(f^*)$1 edge disjoint paths from $v(f^*)$2, we have at least $v(f^*)$3 edges leaving $v(f^*)$4 and entering $v(f^*)$5, and similarly, we have at least $v(f^*)$6 edges leaving $v(f^*)$7 and entering $v(f^*)$8. Otherwise, we wouldn't have enough outgoing or incoming edges to construct said $v(f^*)$9 edge-disjoint paths, since each path leaving $(n - 1)C$0 or $(n - 1)C$1 or entering $(n - 1)C$2 or $(n - 1)C$3 must do so by a unique edge. Therefore, instead of routing $(n - 1)C$4 units of flow from $(n - 1)C$5 into $(n - 1)C$6, and from $(n - 1)C$7 into $(n - 1)C$8, instead route the $(n - 1)C$9 incoming units of flow into $1$0 from the $1$1 capacity $1$2 edges into $1$3, and route the $1$4 units of flow out of $1$5 through the $1$6 outgoing edges of capacity $1$7 from $1$8.</p>
<p>We therefore have a flow from $1$9 of capacity $O(mnC)$0. Since $O(mnC)$1 is only connected to $O(mnC)$2 (with an edge of capacity $O(mnC)$3), and $O(mnC)$4 is only connected to $O(mnC)$5 (with an edge of capacity $O(mnC)$6), and all edges in the middle of said flow have capacity $O(mnC)$7, we must route the $O(mnC)$8 units of flow through $O(mnC)$9 edge disjoint paths from $O(mv(f^*))$0 to $O(mv(f^*))$1, since each such path can only support $O(mv(f^*))$2 unit of flow. Note that the edges in paths between $O(mv(f^*))$3 and $O(mv(f^*))$4, and $O(mv(f^*))$5 and $O(mv(f^*))$6 are not necessarily disjoint, but the edges between $O(mv(f^*))$7 and $O(mv(f^*))$8 that we routed the aforementioned flow through must be disjoint, since that is the only way to route $O(mv(f^*))$9 units of flow through edges all with capacity $G = (V, E)$0.</p>
<h2 id="p3-minimum-vertex-cover-maximum-independent-set-bipartite">P3 - Minimum Vertex Cover, Maximum Independent Set (Bipartite)</h2>
<p>In this exercise we give a polynomial time algorithm to find the minimum vertex cover and maximum independent set in a bipartite graph $G = (V, E)$1.</p>
<h3 id="a-construct-h">(a) Construct H</h3>
<p>Let $G = (V, E)$2 be a directed graph with vertices $G = (V, E)$3 with each edge $G = (V, E)$4, where $G = (V, E)$5 and $G = (V, E)$6 with $G = (V, E)$7. Add vertices $G = (V, E)$8, and edges $G = (V, E)$9 $M \subseteq E$0, and $M \subseteq E$1, $M \subseteq E$2 with $M \subseteq E$3. Let said edges $M \subseteq E$4 and $M \subseteq E$5 form the sets $M \subseteq E$6 and $M \subseteq E$7 respectively.</p>
<h3 id="b-construct-s">(b) Construct S</h3>
<p>Let $M \subseteq E$8 be a min s-t cut in $M \subseteq E$9. I will construct a vertex cover $M$0 such that $M$1. Define the set $M$2 as $M$3, $M$4, $M$5, $M$6 respectively.</p>
<p>The following lemmas will become useful:</p>
<ul>
<li><em>(1)</em>: the capacity of the min s-t cut of $M$7 is upper bounded by $M$8</li>
<li>This is because the maximum flow introduced into the system by $M$9 is $G$0 for each vertex in $G$1.</li>
<li><em>(2)</em>: All $G$2 have capacity $G$3 (by construction).</li>
<li><em>(3)</em>: No edges from $G$4 exist</li>
<li>By <em>(1)</em>, we know $G$5 is finite. Since all edges $G$6 have $G$7, such an edge would imply an infinite capacity between $G$8 and $G$9, which contradicts <em>(1)</em>.</li>
<li><em>(4)</em>: $G = (X \cup Y, E)$0 (proven in lecture)</li>
<li>By <em>(3)</em>, and the fact that $G = (X \cup Y, E)$1 was bipartite and we therefore have no edges between vertices in $G = (X \cup Y, E)$2, we have that all edges from $G = (X \cup Y, E)$3 must be from $G = (X \cup Y, E)$4.</li>
<li>By <em>(2)</em>, we have that each $G = (X \cup Y, E)$5 and $G = (X \cup Y, E)$6 are limited by conservation of capacity, since each have a single incoming and outgoing edge in $G = (X \cup Y, E)$7 and $G = (X \cup Y, E)$8 respectively.</li>
<li>Therefore, we have $G = (X \cup Y, E)$9, since there are $s$00 many edges of capacity $s$01 into $s$02, and $s$03 many edges of capacity $s$04 into $s$05.</li>
</ul>
<p>By <em>(3)</em>, all edges of $s$06 must fall into sets $s$07 between $s$08, $s$09 between $s$10, and $s$11 between $s$12.</p>
<p>We can therefore select a vertex cover of $s$13, since $s$14 covers $s$15 and $s$16, and $s$17 covers $s$18 and $s$19. By <em>(4)</em>, we have $s$20. Note that this isn't necessarily the minimum vertex cover, but it is a vertex cover of size $s$21.</p>
<h3 id="c-construct-a-b">(c) Construct (A, B)</h3>
<p>Let $s$22 be a minimal vertex cover of $s$23. I will construct a min s-t cut $s$24 in $s$25 such that $s$26.</p>
<p>Since $s$27 is a vertex cover, it must contain at least one vertex from each edge in $s$28. Let $s$29, and $s$30. Since $s$31 is bipartite, we have that each edge between $s$32 and $s$33 in $s$34 contains some vertex in $s$35.</p>
<p>To construct $s$36 with $s$37, we must choose $s$38 vertices from $s$39 to route $s$40 unit of flow through. We can then choose $s$41 distinct arbitrary vertices from $s$42 which are neighbors of the previously chosen vertices to route the $s$43 units of flow through.</p>
<p>We know that $s$44 and $s$45, since if we were to cover all of either $s$46 or $s$47 in $s$48, we would have a candidate vertex cover. This argument holds because $s$49 is bipartite and therefore only has edges between $s$50 and $s$51, and we have an upper bound because $s$52 is minimal.</p>
<p>Additionally, without loss of generality (since we could just exchange $s$53 for $s$54 in $s$55 when constructing $s$56), suppose $s$57. We can choose all of $s$58 to route $s$59 units of flow through, and then additionally for each $s$60 we can pick a neighbor of $s$61, $s$62 to route an additional $s$63 units of flow through to each $s$64. I claim that such a $s$65 always exists, which I will prove by contradiction.</p>
<p>Suppose $s$66 such that $s$67. Then we would have already covered all edges $s$68 for $s$69, and so we could remove $s$70 from our set cover to make a smaller set cover $s$71. However, $s$72 is a minimal set cover, so this is a contradiction.</p>
<p>Therefore, we can create a set of edges $s$73, and $s$74, and since these edges are both vertex disjoint and edge disjoint by construction, we have $s$75.</p>
<p>Letting $s$76 be the set of edges $s$77 directed from $s$78, we can create an s-t cut by cutting $s$79 along all edges in $s$80, along with edges from $s$81 to vertices in $s$82 which were not involved with any edge in $s$83. Note that these two sets of edges we cut disconnect paths which form a partition of paths from $s$84, namely those which contain a vertex involved in some $s$85, and those which don't. Therefore, this is a feasible s-t cut, since all paths from $s$86 to $s$87 disconnected.</p>
<p>Taking $s$88 to be the cut described above, we have exactly $s$89 units of flow leaving $s$90, and by extension $s$91, and also entering $s$92, and by extension $s$93. Therefore, $s$94.</p>
<p>### (d) Design the algorithm</p>
<ul>
<li>Given a bipartite graph $s$95</li>
<li>Construct $s$96 as described in (a), but instead of using edges with capacity $s$97 between $s$98 and $s$99, use edges with capacity $t$00</li>
<li>Find the min s-t cut $t$01 in $t$02 using ford-fulkerson</li>
<li>Let $t$03, $t$04</li>
<li>Return $t$05</li>
</ul>
<p><strong>Correctness</strong>:</p>
<p>As mentioned in lecture, adjusting the edge capacities that were originally $t$06 to $t$07 works here, since we still have the desired property that no edges could exist between $t$08, since this would still respect our upper bound of $t$09 on the capacity of the min s-t cut.</p>
<p>From (c), we know that given a min s-t cut $t$10, we can construct a vertex $t$11 with $t$12. Suppose for the sake of contradiction that $t$13 wasn't minimal, i.e. there exists some min vertex cover $t$14 with $t$15. From (b), we know we can construct an s-t cut $t$16 with $t$17. Then we have $t$18, and so $t$19. However, $t$20 could not have been a min s-t cut, which is a contradiction.</p>
<p>Therefore, we have that for any bipartite graph $t$21 and $t$22 constructed as described in (a), we can find a min s-t cut $t$23 in $t$24, and construct a min vertex cover $t$25 of $t$26 such that $t$27, simply by taking the elements of $t$28 and $t$29.
 as $t$30 as described in (b) and written in my algorithm.</p>
<p><strong>Running Time</strong></p>
<p>For a bipartite graph $t$31 in adjacency list form with $t$32 and $t$33, we can create $t$34 in $t$35, since we only need to add two additional vertices, along with $t$36 additional edges between them, also taking into account the extra initialization of edge capacities which would only involve $t$37 operations.</p>
<p>Then, since we have integer capacities, we can run ford-fulkerson on $t$38 to find the min s-t cut, which will terminate in at most $t$39 iterations, where $t$40 here, each iteration taking $t$41 time to compute the augmenting path, for a total runtime of $t$42.</p>
<p>Since ford-fulkerson outputs the min cut $t$43, each of which are sets with size $t$44, and additionally $t$45 and $t$46 are sets with size $t$47, assuming an efficient implementation of intersection using a hash set, we can compute $t$48 in $t$49, and additionally $t$50 in $t$51. Even with an inefficient implementation using a linear structure, we could perform the intersections in $t$52, and the union in $t$53.</p>
<p>Therefore, the total runtime is $t$54, which is polynomial.</p>
<h2 id="p4-knights">P4 - Knights</h2>
<p>Given an $t$55 chess board where some cells are removed. Design a polynomial time algorithm to find the maximum number of knights that can be placed on this board such that no two knights attack each other.</p>
<p><strong>Algorithm</strong>:</p>
<ul>
<li>Given $t$56, the set of pairs $t$57 that correspond to the cells that are removed, and $t$58 be the size of the chess board.</li>
<li>Create an undirected graph $t$59, where $t$60 is $t$61, i.e. the pairs $t$62 that are not removed</li>
<li>Add edges $t$63 to $t$64 such that knights placed on cells $t$65 and $t$66 attack each other. To compute this, for each $t$67, add edges to all cells $t$68 that are $t$69 cells away horizontally and $t$70 cell away vertically or $t$71 cells away vertically and $t$72 cell away horizontally, but that satisfy $t$73. Given such a cell $t$74, the cells to add edges between would be those that satisfy the predicate...<ul>
<li>$t$75</li>
</ul>
</li>
<li>Find the minimum vertex cover $t$76 of $t$77 using the algorithm from P3.</li>
<li>Return $t$78</li>
</ul>
<p><strong>Running Time</strong>:</p>
<p>To create $t$79, we first create our set of vertices $t$80, which can be done in $t$81 (assuming we can check $t$82 in $t$83n \times n$ grid of boolean values).</p>
<p>Next, in order to compute $t$84, we once again need to iterate through all $t$85 cells, and for each cell, we need to check at most $t$86 cells that could potentially attack the current cell, only adding an edge between them if we haven't done so before. Checking the $t$87 cells is $t$88, so it takes a total time of $t$89 to compute edges.</p>
<p>Our graph therefore has a size of $t$90, and $t$91.</p>
<p>We can then find the maximum independent set of $t$92 by first calculating the minimum vertex cover $t$93 in $t$94, and then the M.I.S as $t$95. However, since $t$96, and we only need to compute the maximum number of placements, we can return $t$97 which can be done in constant time.</p>
<p>Therefore, our total running time is $t$98, which is polynomial.</p>
<p><strong>Proof</strong>:</p>
<p>Let $t$99 be the size of the chess board, and $G$00 be the set of pairs $G$01 that correspond to the cells that are removed. We construct a graph $G$02, with $G$03, and $G$04 being the set of edges between each pair of vertices that correspond to cells that are $G$05 cells away horizontally and $G$06 cell away vertically or $G$07 cells away vertically and $G$08 cell away horizontally.</p>
<p>By virtue of its construction, $G$09 has a vertex for each cell we could place a knight on, since it contains each $G$10 which wasn't removed. Furthermore, the set of edges corresponds to each pair of cells that would attack each other if knights were placed on them, since the cells that a knight placed in $G$11 would attack are exactly those that are $G$12 cells away horizontally and $G$13 cell away vertically or $G$14 cells away vertically and $G$15 cell away horizontally, but that are still within the board and not removed, i.e. pairs $G$16, or more simply $G$17, and that satisfy either $G$18 or $G$19.</p>
<p>Let $G$20 be the maximum independent set of $G$21, and $G$22 be the maximum number of knights that can be placed on the board such that no two knights attack each other. I claim that $G$23, which I will prove by showing that $G$24 and $G$25.</p>
<ul>
<li>$G$26: Since $G$27 is an independent set, no two vertices in $G$28 are adjacent. Therefore, no two knights placed on cells corresponding to vertices in $G$29 would attack each other. Since we defined $G$30 as the maximum number of knights that can be placed on the board such that no two knights attack each other, we have $G$31.</li>
<li>$G$32: Suppose for the sake of contradiction that $G$33.  Then there must exist some set of valid placements $G$34 in which we can place knights such that none of the knights attack each other. By construction of $G$35, we would therefore have no edges between any of the vertices corresponding to pairs in $G$36, and so said vertices would form an independent set, say $G$37. Since $G$38, we have $G$39, which is a contradiction to $G$40 being a maximum independent set.</li>
</ul>
            </div>
            <div class="tags">
                Tags:
                <a href="/tags/bipartite%20matching.html">bipartite matching</a>
                <a href="/tags/ford-fulkerson%20algorithm.html">ford-fulkerson algorithm</a>
                <a href="/tags/independent%20set.html">independent set</a>
                <a href="/tags/max%20flow%20min%20cut.html">max flow min cut</a>
                <a href="/tags/vertex%20cover.html">vertex cover</a>
            </div>
        </article>
    </main>
    <footer role="contentinfo">
        <p>2025, authored by Elijah Melton.</p>
    </footer>
</body>
</html>
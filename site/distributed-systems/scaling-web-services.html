
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scaling Web Services with Distributed Architectures</title>
    <meta name="description" content="Explains how to scale web services using distributed architectures">
    <link rel="canonical" href="https://notes.elimelt.com/distributed-systems/scaling-web-services.html">
    <link rel="stylesheet" href="/css/styles.css">
    <script type="application/ld+json">{"@context": "https://schema.org", "@type": "Article", "headline": "Scaling Web Services with Distributed Architectures", "dateModified": "2025-02-11T16:42:07.825087", "description": "Explains how to scale web services using distributed architectures", "url": "https://notes.elimelt.com/distributed-systems/scaling-web-services.html", "articleSection": "Distributed Systems", "keywords": "distributed systems,two-tier architecture,load balancing,caching,edge computing,service oriented architecture,microservices"}</script>
</head>
<body>
    <header>
        <nav><a href="https://github.com/elimelt/notes" style="font-size:24px; color: white;" class="fa">&#xf09b;</a> | <a href="/index.html">Home</a> | <a href="/categories/index.html">Categories</a> | <a href="/tags/index.html">Tags</a></nav>
        <div class="breadcrumbs"><a href="/index.html">Home</a> » <a href="/categories/distributed%20systems.html">Distributed Systems</a> » Scaling Web Services with Distributed Architectures</div>
    </header>
    <main class="content">
        <h1>Scaling Web Services with Distributed Architectures</h1>
        <h1 id="scaling-web-services-with-distributed-architectures"><a class="toclink" href="#scaling-web-services-with-distributed-architectures">Scaling Web Services with Distributed Architectures</a></h1>
<h2 id="two-tier-architecture"><a class="toclink" href="#two-tier-architecture">Two Tier Architecture</a></h2>
<p>Many companies adopted the idea of a two tier architecture for web services. The idea was to have a scalable number of frontend servers, mapping clients to one of those servers. Then, you could also have a scaled out backend with multiple storage severs, mapping frontend servers to the data they needed in the storage servers.</p>
<h3 id="two-tier-restful-web-architecture"><a class="toclink" href="#two-tier-restful-web-architecture">Two-Tier RESTful Web Architecture</a></h3>
<p>Keep a scalable number stateless servers hosting the client and running application code. Importantly, it doesn't matter if a client server crashes, since the user can just connect to some other client server. At the same time, run a scalable number of backend servers running in a carefully designed distributed system, often using primary/backup or paxos for high availability and fault tolerance. Anything that needs to be persistent across crashes should be handled on the backend.</p>
<h3 id="load-balancing"><a class="toclink" href="#load-balancing">Load Balancing</a></h3>
<p>Typically, the layer between the tiers of such architectures are composed of load balancers, which need to map any given client to a desirable front-end server. This needs to be consistent per connection, which can be done with <code>hash(clientIP, port) -&gt; clientServerIP</code>. Additionally, you need to map each client server to a storage server, which can be done by <code>hash(key) -&gt; storageServerIP</code>, where the key is some identifier for the location of the data in a given query to our storage system.</p>
<p>Importantly, the system should automatically adapt to the addition of any type of server.</p>
<h3 id="three-tier-web-architecture-look-aside-caching"><a class="toclink" href="#three-tier-web-architecture-look-aside-caching">Three-Tier Web Architecture: Look-aside Caching</a></h3>
<p>Also maintain a set of cache servers to offload queries to the storage server. Client servers first send their query to the cache server, and if there is a cache miss they then fall back to the storage servers, and then write the retrieved data to the cache (this is look-aside caching).</p>
<p>There are other ways to do caching. For instance, the cache could directly retrieve values transparently to the client server, such that cache misses don't need to be handled. However, this tightly couples the cache and the storage server, often requiring that all queries pass through the caching layer, making it harder to design the two services independently.</p>
<p>Of course, caching needs to be scalable as well. Cache servers don't necessarily need to be 1:1 with client/storage servers, but they should be able to handle the load of the client servers they are caching for adaptively. They should also ideally have lower latency than actual queries executed in the storage layer.</p>
<h2 id="newer-architectures"><a class="toclink" href="#newer-architectures">Newer Architectures</a></h2>
<h3 id="edge-computing"><a class="toclink" href="#edge-computing">Edge Computing</a></h3>
<p><strong>Moving data processing closer to the client.</strong></p>
<p>Users are often globally distributed, leading to higher latency and thus worse user experience.</p>
<p>To mitigate this, large applications will often be globally distributed in <strong>edge data centers</strong>, ideally with one reasonably near every user. Often, only the web and cache (<em>RESTful</em>) layer are present on the edge, and content can be distributed by "pushing" it to the edge before it is ever requested.</p>
<p>In tandem, <strong>core data centers</strong> host the web, cache, <em>and</em> storage layer, replicating all of this across data centers for disaster tolerance.</p>
<h3 id="service-oriented-architecture"><a class="toclink" href="#service-oriented-architecture">Service Oriented Architecture</a></h3>
<p>Services define external interfaces, and often requires distributed systems that work in a hostile environment. All teams expose the data/functionality through this interface, and <strong>all</strong> communication happens through network calls. Each service runs as a standalone product with its own <em>service level agreement</em> to its clients.</p>
<h3 id="microservices"><a class="toclink" href="#microservices">Microservices</a></h3>
<p>Organize complex distributed applications as a large number of independent services communicating through RPC, each using primary/backup or paxos for high availability and fault tolerance.</p>
<p>This allows for independent development of components of a larger system, where each component can scale independently.</p>
    </main>
    <footer>
        <p>&copy; 2025 Notes Site</p>
    </footer>
</body>
</html>
    
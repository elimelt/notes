
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Synchronizing Access to Shared Objects | Elijah's Notes</title>

    <!-- SEO Meta Tags -->
    <meta name="description" content="Covers the implementation of mutual exclusion mechanisms for synchronizing access to shared objects in operating systems. Discusses formal properties of locks, a case study on thread-safe bounded queues, and various lock implementations such as spinlocks and queuing locks. Also introduces condition variables as a synchronization primitive.">
    <meta name="author" content="Elijah Melton">
    <meta name="robots" content="index, follow">
    <meta name="generator" content="Custom Static Site Generator">
    <link rel="canonical" href="https://notes.elimelt.com/operating-systems/v2-concurrency/5-synchronizing-access-to-shared-objects.html">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:title" content="Synchronizing Access to Shared Objects">
    <meta property="og:description" content="Covers the implementation of mutual exclusion mechanisms for synchronizing access to shared objects in operating systems. Discusses formal properties of locks, a case study on thread-safe bounded queues, and various lock implementations such as spinlocks and queuing locks. Also introduces condition variables as a synchronization primitive.">
    <meta property="og:url" content="https://notes.elimelt.com/operating-systems/v2-concurrency/5-synchronizing-access-to-shared-objects.html">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Synchronizing Access to Shared Objects">
    <meta name="twitter:description" content="Covers the implementation of mutual exclusion mechanisms for synchronizing access to shared objects in operating systems. Discusses formal properties of locks, a case study on thread-safe bounded queues, and various lock implementations such as spinlocks and queuing locks. Also introduces condition variables as a synchronization primitive.">

    <meta name="keywords" content="mutual exclusion,locks,thread-safe,bounded queue,atomic operation">

    <!-- Schema.org JSON-LD -->
    <script type="application/ld+json">
    {"@context": "https://schema.org", "@type": "Article", "headline": "Synchronizing Access to Shared Objects", "dateModified": "2025-02-11T20:49:40.375953", "description": "Covers the implementation of mutual exclusion mechanisms for synchronizing access to shared objects in operating systems. Discusses formal properties of locks, a case study on thread-safe bounded queues, and various lock implementations such as spinlocks and queuing locks. Also introduces condition variables as a synchronization primitive.", "articleSection": "Operating Systems", "keywords": "mutual exclusion,locks,thread-safe,bounded queue,atomic operation"}
    </script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/contrib/auto-render.min.js"></script>

    <!-- Configure KaTeX auto-render -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "\[", right: "\]", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\(", right: "\)", display: false}
                ],
                preProcess: (math) => {
                    console.log("Pre-processing: " + math);
                    math = math.split("\n").map((line) => {
                        if (line.endsWith("\\")) {
                            return line + "\\";
                        }
                        return line;
                    }).join("\n");
                    return math;
                },
                throwOnError: false
            });
        });
    </script>

<style>
    :root {
    --text-color: #1a1a1a;
    --background-color: #ffffff;
    --accent-color: #2563eb;
    --accent-light: rgba(37, 99, 235, 0.1);
    --border-color: #e5e7eb;
    --nav-background: rgba(255, 255, 255, 0.95);
    --code-background: #f3f4f6;
    --transition-speed: 0.2s;
    --content-width: 50rem;
    --spacing-sm: 0.5rem;
    --spacing-md: 1rem;
    --spacing-lg: 2rem;
    --spacing-xl: 3rem;
    --radius-sm: 4px;
    --radius-md: 8px;
    --shadow-sm: 0 1px 3px rgba(0,0,0,0.05);
    --shadow-md: 0 4px 6px rgba(0,0,0,0.05), 0 1px 3px rgba(0,0,0,0.1);
}

@media (prefers-color-scheme: dark) {
    :root {
        --text-color: #f3f4f6;
        --background-color: #1a1a1a;
        --accent-color: #60a5fa;
        --accent-light: rgba(96, 165, 250, 0.1);
        --border-color: #374151;
        --nav-background: rgba(26, 26, 26, 0.95);
        --code-background: #2d3748;
    }
}

/* Reset and base styles */
*, *::before, *::after {
    box-sizing: border-box;
}

html {
    font-size: 100%;
    scroll-behavior: smooth;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    line-height: 1.6;
    max-width: var(--content-width);
    margin: 0 auto;
    padding: var(--spacing-md);
    color: var(--text-color);
    background: var(--background-color);
    transition: background-color var(--transition-speed), color var(--transition-speed);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

@media (min-width: 768px) {
    body {
        padding: var(--spacing-lg);
    }
}

/* Improved navigation */
nav {
    position: sticky;
    top: 0;
    background: var(--nav-background);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-bottom: 1px solid var(--border-color);
    padding: var(--spacing-md) 0;
    margin: calc(-1 * var(--spacing-md));
    margin-bottom: var(--spacing-lg);
    display: flex;
    flex-wrap: wrap;
    gap: var(--spacing-sm);
    z-index: 1000;
    width: calc(100% + var(--spacing-md) * 2);
    padding-left: var(--spacing-md);
    padding-right: var(--spacing-md);
    box-shadow: var(--shadow-sm);
}

@media (min-width: 768px) {
    nav {
        margin: calc(-1 * var(--spacing-lg));
        width: calc(100% + var(--spacing-lg) * 2);
        padding-left: var(--spacing-lg);
        padding-right: var(--spacing-lg);
        gap: var(--spacing-md);
    }
}

nav a {
    color: var(--accent-color);
    text-decoration: none;
    padding: var(--spacing-sm) var(--spacing-md);
    border-radius: var(--radius-sm);
    transition: background-color var(--transition-speed), color var(--transition-speed);
    font-weight: 500;
}

nav a:hover, nav a:focus {
    background-color: var(--accent-light);
    outline: none;
}

nav a:focus-visible {
    outline: 2px solid var(--accent-color);
    outline-offset: 2px;
}

/* Improved breadcrumbs */
.breadcrumbs {
    margin-bottom: var(--spacing-lg);
    color: var(--text-color);
    opacity: 0.8;
    font-size: 0.9rem;
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    align-items: center;
}

.breadcrumbs a {
    color: var(--accent-color);
    text-decoration: none;
    transition: color var(--transition-speed);
}

.breadcrumbs a:hover {
    text-decoration: underline;
}

.breadcrumbs span:not(:last-child)::after {
    content: "/";
    margin-left: 0.5rem;
    opacity: 0.5;
}

/* Article styles */
article {
    margin-bottom: var(--spacing-xl);
}

h1, h2, h3, h4, h5, h6 {
    margin-top: var(--spacing-lg);
    margin-bottom: var(--spacing-md);
    line-height: 1.3;
    font-weight: 600;
}

h1 {
    font-size: 2rem;
    margin-top: 0;
}

h2 {
    font-size: 1.5rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid var(--border-color);
}

/* Meta information styling */
.meta {
    color: var(--text-color);
    opacity: 0.8;
    font-size: 0.9rem;
    margin-bottom: var(--spacing-lg);
    display: flex;
    flex-wrap: wrap;
    gap: var(--spacing-md);
    padding-bottom: var(--spacing-md);
    border-bottom: 1px solid var(--border-color);
}

/* Improved code blocks */
code {
    background: var(--code-background);
    padding: 0.2rem 0.4rem;
    border-radius: var(--radius-sm);
    font-size: 0.9em;
    font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
}

pre {
    background: var(--code-background);
    padding: var(--spacing-md);
    border-radius: var(--radius-md);
    overflow-x: auto;
    margin: var(--spacing-lg) 0;
    box-shadow: var(--shadow-sm);
}

pre code {
    background: none;
    padding: 0;
    border-radius: 0;
}

/* Improved links */
a {
    color: var(--accent-color);
    text-decoration: none;
    transition: color var(--transition-speed);
}

a:hover {
    text-decoration: underline;
}

/* Improved image handling */
img {
    max-width: 100%;
    height: auto;
    border-radius: var(--radius-md);
    margin: var(--spacing-lg) 0;
    display: block;
    box-shadow: var(--shadow-md);
}

/* Table improvements */
table {
    width: 100%;
    border-collapse: collapse;
    margin: var(--spacing-lg) 0;
    overflow-x: auto;
    display: block;
    border-radius: var(--radius-sm);
    box-shadow: var(--shadow-sm);
}

@media (min-width: 768px) {
    table {
        display: table;
    }
}

th, td {
    padding: 0.75rem;
    border: 1px solid var(--border-color);
    text-align: left;
}

th {
    background: var(--border-color);
    font-weight: 600;
}

/* Tags styling */
.tags {
    margin-top: var(--spacing-lg);
    padding-top: var(--spacing-md);
    border-top: 1px solid var(--border-color);
}

.tags a {
    display: inline-block;
    background: var(--border-color);
    color: var(--text-color);
    padding: 0.2rem 0.6rem;
    border-radius: var(--radius-sm);
    text-decoration: none;
    font-size: 0.9em;
    margin-right: 0.5rem;
    margin-bottom: 0.5rem;
    transition: background-color var(--transition-speed), color var(--transition-speed);
}

.tags a:hover {
    background: var(--accent-color);
    color: white;
    text-decoration: none;
}

/* Footer improvements */
footer {
    margin-top: var(--spacing-xl);
    padding-top: var(--spacing-md);
    border-top: 1px solid var(--border-color);
    text-align: center;
    font-size: 0.9rem;
    opacity: 0.8;
}

/* Blockquote styling */
blockquote {
    margin: var(--spacing-lg) 0;
    padding-left: var(--spacing-md);
    border-left: 4px solid var(--accent-color);
    color: var(--text-color);
    opacity: 0.9;
    font-style: italic;
}

/* Improved KaTeX rendering */
.katex-display {
    overflow: auto hidden;
    padding: var(--spacing-md) 0;
    margin: var(--spacing-md) 0;
    background: var(--accent-light);
    border-radius: var(--radius-md);
    padding: var(--spacing-md);
}

.katex-display > .katex {
    white-space: normal;
}

.katex {
    font-size: 1.1em;
    line-height: 1.2;
}

.katex-display .katex {
    display: block;
    text-align: center;
}

.katex-display > .katex > .katex-html {
    display: block;
    max-width: 100%;
    overflow-x: auto;
    padding: 0.5em 0;
    min-height: 40px;
}

/* Index page styling */
.landing-stats {
    display: flex;
    flex-wrap: wrap;
    gap: var(--spacing-md);
    margin-bottom: var(--spacing-lg);
    justify-content: space-around;
}

.stat-item {
    text-align: center;
    padding: var(--spacing-md);
    background: var(--accent-light);
    border-radius: var(--radius-md);
    flex: 1;
    min-width: 100px;
    box-shadow: var(--shadow-sm);
}

.stat-value {
    display: block;
    font-size: 1.5rem;
    font-weight: bold;
    color: var(--accent-color);
}

.stat-label {
    font-size: 0.9rem;
    opacity: 0.8;
}

.landing-grid {
    display: grid;
    grid-template-columns: 1fr;
    gap: var(--spacing-lg);
}

@media (min-width: 768px) {
    .landing-grid {
        grid-template-columns: 3fr 1fr;
    }

    .recent-section {
        grid-column: 1 / 2;
    }

    .categories-section, .tags-section {
        grid-column: 2 / 3;
    }
}

.recent-posts, .categories-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

.recent-posts li, .categories-list li {
    padding: var(--spacing-sm) 0;
    border-bottom: 1px solid var(--border-color);
}

.recent-posts li:last-child, .categories-list li:last-child {
    border-bottom: none;
}

.recent-posts .date, .recent-posts .category, .categories-list .count {
    font-size: 0.85rem;
    opacity: 0.7;
    margin-left: var(--spacing-sm);
}

.tags-cloud {
    display: flex;
    flex-wrap: wrap;
    gap: var(--spacing-sm);
}

.tags-cloud a {
    padding: var(--spacing-sm) var(--spacing-md);
    background: var(--border-color);
    border-radius: var(--radius-sm);
    text-decoration: none;
    transition: background-color var(--transition-speed), color var(--transition-speed);
}

.tags-cloud a:hover {
    background: var(--accent-color);
    color: white;
    text-decoration: none;
}

.tag-size-1 { font-size: 0.8rem; }
.tag-size-2 { font-size: 0.9rem; }
.tag-size-3 { font-size: 1rem; }
.tag-size-4 { font-size: 1.1rem; }
.tag-size-5 { font-size: 1.2rem; }

/* Focus styles for accessibility */
*:focus-visible {
    outline: 2px solid var(--accent-color);
    outline-offset: 2px;
}

/* Print styles */
@media print {
    nav, .breadcrumbs, .tags, footer {
        display: none;
    }

    body {
        max-width: none;
        padding: 0;
        color: black;
        background: white;
    }

    a {
        color: black;
        text-decoration: underline;
    }

    .content {
        max-width: 100%;
    }
}
</style></head>
<body>
    <header>
        <nav role="navigation" aria-label="Main navigation">
            <a href="/index.html">Home</a>
<a href="/categories/index.html">Categories</a>
<a href="/tags/index.html">Tags</a>
        </nav>
        <div class="breadcrumbs" role="navigation" aria-label="Breadcrumb">
            <a href="/index.html">Home</a> » <a href="/categories/operating%20systems.html">Operating Systems</a> » Synchronizing Access to Shared Objects
        </div>
    </header>
    <main role="main">
        <article>
            <h1>Synchronizing Access to Shared Objects</h1>
            <div class="meta">
                <time datetime="2025-02-11T20:49:40.375953">
                    Last modified: 2025-02-11
                </time>
                <span>Category: <a href="/categories/operating%20systems.html">Operating Systems</a></span>
            </div>
            <div class="content">
                <h1 id="synchronizing-access-to-shared-objects">Synchronizing Access to Shared Objects</h1>
<h2 id="locks-mutual-exclusion">Locks: Mutual Exclusion</h2>
<p>Locks enable mutual exclusion with two operations: <code>acquire</code> and <code>release</code>.</p>
<ul>
<li>A lock can be in one of two states: <code>BUSY</code> or <code>FREE</code>.</li>
<li>Initially, the lock is <code>FREE</code>.</li>
<li><code>acquire</code> waits until the lock is <code>FREE</code>, then sets it to <code>BUSY</code>.</li>
<li>This needs to be an atomic operation, and is typically implemented to be so in hardware.</li>
<li><code>release</code> sets the lock to <code>FREE</code>. If there are processes waiting to acquire the lock, one of them is able to proceed after the lock is released.</li>
</ul>
<h3 id="formal-properties">Formal Properties</h3>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mutual Exclusion</td>
<td>At most one process can hold the lock at a time.</td>
</tr>
<tr>
<td>Progress</td>
<td>If no process holds the lock and some process wants to acquire it, then some process will eventually acquire the lock.</td>
</tr>
<tr>
<td>Bounded Waiting</td>
<td>There is a bound on the number of times that other processes can acquire the lock after a process has requested to acquire the lock.</td>
</tr>
</tbody>
</table>
<h3 id="case-study-thread-safe-bounded-queue">Case Study: Thread-Safe Bounded Queue</h3>
<pre><code class="language-cpp">// Thread-safe queue interface
const int MAX = 10;
class ConcurrentQueue {
  // Synchronization variables
  Lock lock;
  // State variables
  int items[MAX];
  int front;
  int nextEmpty;

  public:
    ConcurrentQueue();
    ~ConcurrentQueue(){};
    bool tryInsert(int item);
    bool tryRemove(int *item);
};

// Initialize the queue to empty
// and the lock to free.
ConcurrentQueue::ConcurrentQueue() {
  front = nextEmpty = 0;
}

// Try to insert an item. If the queue is
// full, return false; otherwise return true.
bool ConcurrentQueue::tryInsert(int item) {
  bool success = false;
  lock.acquire();

  if ((nextEmpty - front) &lt; MAX) {
    items[nextEmpty % MAX] = item;
    nextEmpty++;
    success = true;
  }

  lock.release();
  return success;
}
// Try to remove an item. If the queue is
// empty, return false; otherwise return true.
bool ConcurrentQueue::tryRemove(int *item) {
  bool success = false;
  lock.acquire();

  if (front &lt; nextEmpty) {
    *item = items[front % MAX];
    front++;
    success = true;
  }

  lock.release();
  return success;
}
</code></pre>
<p>And here is a simple test program that uses the queue:</p>
<pre><code class="language-cpp">int main(int argc, char **argv) {
  ConcurrentQueue *queues[3];
  sthread_t workers[3];
  int i, j;
  // Start worker threads to insert.
  for (i = 0; i &lt; 3; i++) {
    queues[i] = new ConcurrentQueue();
    thread_create_p(&amp;workers[i],
    putSome, queues[i]);
  }

  // Wait for some items to be put.
  thread_join(workers[0]);

  // Remove 20 items from each queue.
  for (i = 0; i &lt; 3; i++) {
    printf(&quot;Queue %d:\n&quot;, i);
    testRemoval(&amp;queues[i]);
  }
}

// Insert 50 items into a queue.
void *putSome(void *p) {
  ConcurrentQueue *queue = (ConcurrentQueue *)p;
  for (int i = 0; i &lt; 50; i++)
    queue-&gt;tryInsert(i);

  return NULL;
}
// Remove 20 items from a queue.
void testRemoval(ConcurrentQueue *queue) {
  int item;
  for (int i = 0; i &lt; 20; j++) {
    if (queue-&gt;tryRemove(&amp;item))
      printf(&quot;Removed %d\n&quot;, item);
    else
      printf(&quot;Nothing there.\n&quot;);
  }
}
 ```

## Spinlocks

A spinlock is a lock that causes a process trying to acquire it to simply wait in a loop while repeatedly checking if the lock is available. They should be used only when the lock is expected to be held for a short period of time, ie. when the time to acquire the lock is less than the time to context switch. While waiting for the lock, the process continues to run and waste CPU cycles.

### Implementing Multiprocessor Spinlocks

Most processor architectures provide atomic `read-modify-write` instructions that acquires an exclusive copy of a given physical memory location, similar to underlying mechanisms for cache coherence among multiple processors. These instructions are used to implement spinlocks. For example, the `test-and-set` instruction atomically sets a memory location to 1 and returns its previous value. This can be used to implement a lock as follows:

```cpp
struct spinlock {
  int held = 0;
}
void acquire(lock) {
  while(test_and_set(&amp;lock-&gt;held));
}

void release(lock) {
  lock-&gt;held = 0;
}
</code></pre>
<h2 id="queuing-locks">Queuing Locks</h2>
<p>Sometimes want to accommodate both short and long critical sections while still minimizing overhead. It is not possible to completely avoid busy waiting on a multiprocessor, but you can minimize it by using a queuing lock.</p>
<p>With a queuing lock, access to the underlying data structure is controlled by a spinlock. On <code>acquire</code>, if the lock is <code>FREE</code>, the process can proceed. If the lock is <code>BUSY</code>, the process is added to a queue and suspended. When the lock is released, the next process in the queue is resumed.</p>
<p>To suspend a thread on a multiprocessor using this type of lock, first need to disable interrupts so it isn't preempted while holding the ready lists spinlock. Then, acquire the ready list spinlock, and then release the queuing lock's spinlock. Finally, switch to the next thread in the ready list and release the ready list spinlock.</p>
<pre><code class="language-cpp">class Lock {
 private:
  int value = FREE;
  SpinLock spinLock;
  Queue waiting;
 public:
  void acquire();
  void release();
};

Lock::acquire() {
  spinLock.acquire();
  if (value != FREE) {
    waiting.add(runningThread);
    scheduler.suspend(&amp;spinLock);
    // scheduler releases spinLock
  } else {
    value = BUSY;
    spinLock.release();
  }
}

void Lock::release() {
  TCB *next;
  spinLock.acquire();
  if (waiting.notEmpty()) {
    next = waiting.remove();
    scheduler.makeReady(next);
  } else {
    value = FREE;
  }
  spinLock.release();
}

class Scheduler {
 private:
  Queue readyList;
  SpinLock schedulerSpinLock;
 public:
  void suspend(SpinLock *lock);
  void makeReady(Thread *thread);
}

void Scheduler::suspend(SpinLock *lock) {
  TCB *chosenTCB;
  disableInterrupts();
  schedulerSpinLock.acquire();
  lock-&gt;release();
  runningThread-&gt;state = WAITING;
  chosenTCB = readyList.getNextThread();
  thread_switch(runningThread, chosenTCB);
  runningThread-&gt;state = RUNNING;
  schedulerSpinLock.release();
  enableInterrupts();
}

void Scheduler::makeReady(TCB *thread) {
  disableInterrupts();
  schedulerSpinLock.acquire();
  readyList.add(thread);
  thread-&gt;state = READY;
  schedulerSpinLock.release();
  enableInterrupts();
}
 ```

 ### Case Study: Linux 2.6 Kernel Mutex Lock

 In Linux, most locks are `FREE` most of the time. Additionally, if a lock is `BUSY`, it is still likely that no other locks are waiting for it. THe Linux implementation of a mutex lock optimizes for this commone case by providing a fast path for the case where threads don't need to wait.

 Linux utilizes x86 specific instructions that allow the lock to be acquired and released on the fast path *without* first acquiring the spinlock or disabling interrupts. Mutexes have 3 possible states:

 ```c
 struct mutex {
  /* 1: unlocked, 0: locked, negative: locked, possible waiters */
  atomic_t count;
  spinlock_t wait_lock;
  struct list_head wait_list;
 };
 ```

 The Linux lock `acquire` code is a macro to avoid the overhead of a function call on the fast path.

```asm
      lock decl (%eax)      // atomic decrement of a memory location
                            // address in %eax is pointer to lock-&gt;count
      jns 1f                // jump if not signed (if value is now 0)
      call slowpath_acquire
</code></pre>
<p>```c
  for (;;) {
  /<em>
  * Lets try to take the lock again - this is needed even if
  * we get here for the first time (shortly after failing to
  * acquire the lock), to make sure that we get a wakeup once
  * it's unlocked. Later on, if we sleep, this is the
  * operation that gives us the lock. We xchg it to -1, so
  * that when we release the lock, we properly wake up the
  * other waiters:
  </em>/
  if (atomic_xchg(&amp;lock-&gt;count, -1) == 1)
    break;</p>
<p>/<em> didn't get the lock, go to sleep: </em>/
  ...
 }
 ```</p>
<h2 id="condition-variables">Condition Variables</h2>
<p>Condition variables are used to wait for a particular condition to become true. They are used in conjunction with locks to provide a way for a thread to be woken up when a condition becomes true. The condition variable is associated with a lock, and the lock must be held when waiting on the condition variable.</p>
            </div>
            <div class="tags">
                Tags:
                <a href="/tags/atomic%20operation.html">atomic operation</a>
                <a href="/tags/bounded%20queue.html">bounded queue</a>
                <a href="/tags/locks.html">locks</a>
                <a href="/tags/mutual%20exclusion.html">mutual exclusion</a>
                <a href="/tags/thread-safe.html">thread-safe</a>
            </div>
        </article>
    </main>
    <footer role="contentinfo">
        <p>2025, authored by Elijah Melton.</p>
    </footer>
</body>
</html>